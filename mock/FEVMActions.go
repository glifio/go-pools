// Code generated by mockery v2.53.5. DO NOT EDIT.

package mock

import (
	big "math/big"

	address "github.com/filecoin-project/go-address"

	bind "github.com/ethereum/go-ethereum/accounts/abi/bind"

	common "github.com/ethereum/go-ethereum/common"

	context "context"

	ecdsa "crypto/ecdsa"

	mock "github.com/stretchr/testify/mock"

	types "github.com/ethereum/go-ethereum/core/types"
)

// FEVMActions is an autogenerated mock type for the FEVMActions type
type FEVMActions struct {
	mock.Mock
}

type FEVMActions_Expecter struct {
	mock *mock.Mock
}

func (_m *FEVMActions) EXPECT() *FEVMActions_Expecter {
	return &FEVMActions_Expecter{mock: &_m.Mock}
}

// AgentAcceptOperator provides a mock function with given fields: ctx, auth, agentAddr
func (_m *FEVMActions) AgentAcceptOperator(ctx context.Context, auth *bind.TransactOpts, agentAddr common.Address) (*types.Transaction, error) {
	ret := _m.Called(ctx, auth, agentAddr)

	if len(ret) == 0 {
		panic("no return value specified for AgentAcceptOperator")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, common.Address) (*types.Transaction, error)); ok {
		return rf(ctx, auth, agentAddr)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, common.Address) *types.Transaction); ok {
		r0 = rf(ctx, auth, agentAddr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.TransactOpts, common.Address) error); ok {
		r1 = rf(ctx, auth, agentAddr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMActions_AgentAcceptOperator_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentAcceptOperator'
type FEVMActions_AgentAcceptOperator_Call struct {
	*mock.Call
}

// AgentAcceptOperator is a helper method to define mock.On call
//   - ctx context.Context
//   - auth *bind.TransactOpts
//   - agentAddr common.Address
func (_e *FEVMActions_Expecter) AgentAcceptOperator(ctx interface{}, auth interface{}, agentAddr interface{}) *FEVMActions_AgentAcceptOperator_Call {
	return &FEVMActions_AgentAcceptOperator_Call{Call: _e.mock.On("AgentAcceptOperator", ctx, auth, agentAddr)}
}

func (_c *FEVMActions_AgentAcceptOperator_Call) Run(run func(ctx context.Context, auth *bind.TransactOpts, agentAddr common.Address)) *FEVMActions_AgentAcceptOperator_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.TransactOpts), args[2].(common.Address))
	})
	return _c
}

func (_c *FEVMActions_AgentAcceptOperator_Call) Return(_a0 *types.Transaction, _a1 error) *FEVMActions_AgentAcceptOperator_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMActions_AgentAcceptOperator_Call) RunAndReturn(run func(context.Context, *bind.TransactOpts, common.Address) (*types.Transaction, error)) *FEVMActions_AgentAcceptOperator_Call {
	_c.Call.Return(run)
	return _c
}

// AgentAcceptOwnership provides a mock function with given fields: ctx, auth, agentAddr
func (_m *FEVMActions) AgentAcceptOwnership(ctx context.Context, auth *bind.TransactOpts, agentAddr common.Address) (*types.Transaction, error) {
	ret := _m.Called(ctx, auth, agentAddr)

	if len(ret) == 0 {
		panic("no return value specified for AgentAcceptOwnership")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, common.Address) (*types.Transaction, error)); ok {
		return rf(ctx, auth, agentAddr)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, common.Address) *types.Transaction); ok {
		r0 = rf(ctx, auth, agentAddr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.TransactOpts, common.Address) error); ok {
		r1 = rf(ctx, auth, agentAddr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMActions_AgentAcceptOwnership_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentAcceptOwnership'
type FEVMActions_AgentAcceptOwnership_Call struct {
	*mock.Call
}

// AgentAcceptOwnership is a helper method to define mock.On call
//   - ctx context.Context
//   - auth *bind.TransactOpts
//   - agentAddr common.Address
func (_e *FEVMActions_Expecter) AgentAcceptOwnership(ctx interface{}, auth interface{}, agentAddr interface{}) *FEVMActions_AgentAcceptOwnership_Call {
	return &FEVMActions_AgentAcceptOwnership_Call{Call: _e.mock.On("AgentAcceptOwnership", ctx, auth, agentAddr)}
}

func (_c *FEVMActions_AgentAcceptOwnership_Call) Run(run func(ctx context.Context, auth *bind.TransactOpts, agentAddr common.Address)) *FEVMActions_AgentAcceptOwnership_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.TransactOpts), args[2].(common.Address))
	})
	return _c
}

func (_c *FEVMActions_AgentAcceptOwnership_Call) Return(_a0 *types.Transaction, _a1 error) *FEVMActions_AgentAcceptOwnership_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMActions_AgentAcceptOwnership_Call) RunAndReturn(run func(context.Context, *bind.TransactOpts, common.Address) (*types.Transaction, error)) *FEVMActions_AgentAcceptOwnership_Call {
	_c.Call.Return(run)
	return _c
}

// AgentAddMiner provides a mock function with given fields: ctx, auth, agentAddr, minerAddr, requesterKey
func (_m *FEVMActions) AgentAddMiner(ctx context.Context, auth *bind.TransactOpts, agentAddr common.Address, minerAddr address.Address, requesterKey *ecdsa.PrivateKey) (*types.Transaction, error) {
	ret := _m.Called(ctx, auth, agentAddr, minerAddr, requesterKey)

	if len(ret) == 0 {
		panic("no return value specified for AgentAddMiner")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, common.Address, address.Address, *ecdsa.PrivateKey) (*types.Transaction, error)); ok {
		return rf(ctx, auth, agentAddr, minerAddr, requesterKey)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, common.Address, address.Address, *ecdsa.PrivateKey) *types.Transaction); ok {
		r0 = rf(ctx, auth, agentAddr, minerAddr, requesterKey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.TransactOpts, common.Address, address.Address, *ecdsa.PrivateKey) error); ok {
		r1 = rf(ctx, auth, agentAddr, minerAddr, requesterKey)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMActions_AgentAddMiner_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentAddMiner'
type FEVMActions_AgentAddMiner_Call struct {
	*mock.Call
}

// AgentAddMiner is a helper method to define mock.On call
//   - ctx context.Context
//   - auth *bind.TransactOpts
//   - agentAddr common.Address
//   - minerAddr address.Address
//   - requesterKey *ecdsa.PrivateKey
func (_e *FEVMActions_Expecter) AgentAddMiner(ctx interface{}, auth interface{}, agentAddr interface{}, minerAddr interface{}, requesterKey interface{}) *FEVMActions_AgentAddMiner_Call {
	return &FEVMActions_AgentAddMiner_Call{Call: _e.mock.On("AgentAddMiner", ctx, auth, agentAddr, minerAddr, requesterKey)}
}

func (_c *FEVMActions_AgentAddMiner_Call) Run(run func(ctx context.Context, auth *bind.TransactOpts, agentAddr common.Address, minerAddr address.Address, requesterKey *ecdsa.PrivateKey)) *FEVMActions_AgentAddMiner_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.TransactOpts), args[2].(common.Address), args[3].(address.Address), args[4].(*ecdsa.PrivateKey))
	})
	return _c
}

func (_c *FEVMActions_AgentAddMiner_Call) Return(_a0 *types.Transaction, _a1 error) *FEVMActions_AgentAddMiner_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMActions_AgentAddMiner_Call) RunAndReturn(run func(context.Context, *bind.TransactOpts, common.Address, address.Address, *ecdsa.PrivateKey) (*types.Transaction, error)) *FEVMActions_AgentAddMiner_Call {
	_c.Call.Return(run)
	return _c
}

// AgentBorrow provides a mock function with given fields: ctx, auth, agentAddr, poolID, amount, requesterKey
func (_m *FEVMActions) AgentBorrow(ctx context.Context, auth *bind.TransactOpts, agentAddr common.Address, poolID *big.Int, amount *big.Int, requesterKey *ecdsa.PrivateKey) (*types.Transaction, error) {
	ret := _m.Called(ctx, auth, agentAddr, poolID, amount, requesterKey)

	if len(ret) == 0 {
		panic("no return value specified for AgentBorrow")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, common.Address, *big.Int, *big.Int, *ecdsa.PrivateKey) (*types.Transaction, error)); ok {
		return rf(ctx, auth, agentAddr, poolID, amount, requesterKey)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, common.Address, *big.Int, *big.Int, *ecdsa.PrivateKey) *types.Transaction); ok {
		r0 = rf(ctx, auth, agentAddr, poolID, amount, requesterKey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.TransactOpts, common.Address, *big.Int, *big.Int, *ecdsa.PrivateKey) error); ok {
		r1 = rf(ctx, auth, agentAddr, poolID, amount, requesterKey)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMActions_AgentBorrow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentBorrow'
type FEVMActions_AgentBorrow_Call struct {
	*mock.Call
}

// AgentBorrow is a helper method to define mock.On call
//   - ctx context.Context
//   - auth *bind.TransactOpts
//   - agentAddr common.Address
//   - poolID *big.Int
//   - amount *big.Int
//   - requesterKey *ecdsa.PrivateKey
func (_e *FEVMActions_Expecter) AgentBorrow(ctx interface{}, auth interface{}, agentAddr interface{}, poolID interface{}, amount interface{}, requesterKey interface{}) *FEVMActions_AgentBorrow_Call {
	return &FEVMActions_AgentBorrow_Call{Call: _e.mock.On("AgentBorrow", ctx, auth, agentAddr, poolID, amount, requesterKey)}
}

func (_c *FEVMActions_AgentBorrow_Call) Run(run func(ctx context.Context, auth *bind.TransactOpts, agentAddr common.Address, poolID *big.Int, amount *big.Int, requesterKey *ecdsa.PrivateKey)) *FEVMActions_AgentBorrow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.TransactOpts), args[2].(common.Address), args[3].(*big.Int), args[4].(*big.Int), args[5].(*ecdsa.PrivateKey))
	})
	return _c
}

func (_c *FEVMActions_AgentBorrow_Call) Return(_a0 *types.Transaction, _a1 error) *FEVMActions_AgentBorrow_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMActions_AgentBorrow_Call) RunAndReturn(run func(context.Context, *bind.TransactOpts, common.Address, *big.Int, *big.Int, *ecdsa.PrivateKey) (*types.Transaction, error)) *FEVMActions_AgentBorrow_Call {
	_c.Call.Return(run)
	return _c
}

// AgentChangeMinerWorker provides a mock function with given fields: ctx, auth, agentAddr, minerAddr, workerAddr, controlAddrs
func (_m *FEVMActions) AgentChangeMinerWorker(ctx context.Context, auth *bind.TransactOpts, agentAddr common.Address, minerAddr address.Address, workerAddr address.Address, controlAddrs []address.Address) (*types.Transaction, error) {
	ret := _m.Called(ctx, auth, agentAddr, minerAddr, workerAddr, controlAddrs)

	if len(ret) == 0 {
		panic("no return value specified for AgentChangeMinerWorker")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, common.Address, address.Address, address.Address, []address.Address) (*types.Transaction, error)); ok {
		return rf(ctx, auth, agentAddr, minerAddr, workerAddr, controlAddrs)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, common.Address, address.Address, address.Address, []address.Address) *types.Transaction); ok {
		r0 = rf(ctx, auth, agentAddr, minerAddr, workerAddr, controlAddrs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.TransactOpts, common.Address, address.Address, address.Address, []address.Address) error); ok {
		r1 = rf(ctx, auth, agentAddr, minerAddr, workerAddr, controlAddrs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMActions_AgentChangeMinerWorker_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentChangeMinerWorker'
type FEVMActions_AgentChangeMinerWorker_Call struct {
	*mock.Call
}

// AgentChangeMinerWorker is a helper method to define mock.On call
//   - ctx context.Context
//   - auth *bind.TransactOpts
//   - agentAddr common.Address
//   - minerAddr address.Address
//   - workerAddr address.Address
//   - controlAddrs []address.Address
func (_e *FEVMActions_Expecter) AgentChangeMinerWorker(ctx interface{}, auth interface{}, agentAddr interface{}, minerAddr interface{}, workerAddr interface{}, controlAddrs interface{}) *FEVMActions_AgentChangeMinerWorker_Call {
	return &FEVMActions_AgentChangeMinerWorker_Call{Call: _e.mock.On("AgentChangeMinerWorker", ctx, auth, agentAddr, minerAddr, workerAddr, controlAddrs)}
}

func (_c *FEVMActions_AgentChangeMinerWorker_Call) Run(run func(ctx context.Context, auth *bind.TransactOpts, agentAddr common.Address, minerAddr address.Address, workerAddr address.Address, controlAddrs []address.Address)) *FEVMActions_AgentChangeMinerWorker_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.TransactOpts), args[2].(common.Address), args[3].(address.Address), args[4].(address.Address), args[5].([]address.Address))
	})
	return _c
}

func (_c *FEVMActions_AgentChangeMinerWorker_Call) Return(_a0 *types.Transaction, _a1 error) *FEVMActions_AgentChangeMinerWorker_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMActions_AgentChangeMinerWorker_Call) RunAndReturn(run func(context.Context, *bind.TransactOpts, common.Address, address.Address, address.Address, []address.Address) (*types.Transaction, error)) *FEVMActions_AgentChangeMinerWorker_Call {
	_c.Call.Return(run)
	return _c
}

// AgentChangeRequester provides a mock function with given fields: ctx, auth, agentAddr, newRequester
func (_m *FEVMActions) AgentChangeRequester(ctx context.Context, auth *bind.TransactOpts, agentAddr common.Address, newRequester common.Address) (*types.Transaction, error) {
	ret := _m.Called(ctx, auth, agentAddr, newRequester)

	if len(ret) == 0 {
		panic("no return value specified for AgentChangeRequester")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, common.Address, common.Address) (*types.Transaction, error)); ok {
		return rf(ctx, auth, agentAddr, newRequester)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, common.Address, common.Address) *types.Transaction); ok {
		r0 = rf(ctx, auth, agentAddr, newRequester)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.TransactOpts, common.Address, common.Address) error); ok {
		r1 = rf(ctx, auth, agentAddr, newRequester)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMActions_AgentChangeRequester_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentChangeRequester'
type FEVMActions_AgentChangeRequester_Call struct {
	*mock.Call
}

// AgentChangeRequester is a helper method to define mock.On call
//   - ctx context.Context
//   - auth *bind.TransactOpts
//   - agentAddr common.Address
//   - newRequester common.Address
func (_e *FEVMActions_Expecter) AgentChangeRequester(ctx interface{}, auth interface{}, agentAddr interface{}, newRequester interface{}) *FEVMActions_AgentChangeRequester_Call {
	return &FEVMActions_AgentChangeRequester_Call{Call: _e.mock.On("AgentChangeRequester", ctx, auth, agentAddr, newRequester)}
}

func (_c *FEVMActions_AgentChangeRequester_Call) Run(run func(ctx context.Context, auth *bind.TransactOpts, agentAddr common.Address, newRequester common.Address)) *FEVMActions_AgentChangeRequester_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.TransactOpts), args[2].(common.Address), args[3].(common.Address))
	})
	return _c
}

func (_c *FEVMActions_AgentChangeRequester_Call) Return(_a0 *types.Transaction, _a1 error) *FEVMActions_AgentChangeRequester_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMActions_AgentChangeRequester_Call) RunAndReturn(run func(context.Context, *bind.TransactOpts, common.Address, common.Address) (*types.Transaction, error)) *FEVMActions_AgentChangeRequester_Call {
	_c.Call.Return(run)
	return _c
}

// AgentConfirmMinerWorkerChange provides a mock function with given fields: ctx, auth, agentAddr, minerAddr
func (_m *FEVMActions) AgentConfirmMinerWorkerChange(ctx context.Context, auth *bind.TransactOpts, agentAddr common.Address, minerAddr address.Address) (*types.Transaction, error) {
	ret := _m.Called(ctx, auth, agentAddr, minerAddr)

	if len(ret) == 0 {
		panic("no return value specified for AgentConfirmMinerWorkerChange")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, common.Address, address.Address) (*types.Transaction, error)); ok {
		return rf(ctx, auth, agentAddr, minerAddr)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, common.Address, address.Address) *types.Transaction); ok {
		r0 = rf(ctx, auth, agentAddr, minerAddr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.TransactOpts, common.Address, address.Address) error); ok {
		r1 = rf(ctx, auth, agentAddr, minerAddr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMActions_AgentConfirmMinerWorkerChange_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentConfirmMinerWorkerChange'
type FEVMActions_AgentConfirmMinerWorkerChange_Call struct {
	*mock.Call
}

// AgentConfirmMinerWorkerChange is a helper method to define mock.On call
//   - ctx context.Context
//   - auth *bind.TransactOpts
//   - agentAddr common.Address
//   - minerAddr address.Address
func (_e *FEVMActions_Expecter) AgentConfirmMinerWorkerChange(ctx interface{}, auth interface{}, agentAddr interface{}, minerAddr interface{}) *FEVMActions_AgentConfirmMinerWorkerChange_Call {
	return &FEVMActions_AgentConfirmMinerWorkerChange_Call{Call: _e.mock.On("AgentConfirmMinerWorkerChange", ctx, auth, agentAddr, minerAddr)}
}

func (_c *FEVMActions_AgentConfirmMinerWorkerChange_Call) Run(run func(ctx context.Context, auth *bind.TransactOpts, agentAddr common.Address, minerAddr address.Address)) *FEVMActions_AgentConfirmMinerWorkerChange_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.TransactOpts), args[2].(common.Address), args[3].(address.Address))
	})
	return _c
}

func (_c *FEVMActions_AgentConfirmMinerWorkerChange_Call) Return(_a0 *types.Transaction, _a1 error) *FEVMActions_AgentConfirmMinerWorkerChange_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMActions_AgentConfirmMinerWorkerChange_Call) RunAndReturn(run func(context.Context, *bind.TransactOpts, common.Address, address.Address) (*types.Transaction, error)) *FEVMActions_AgentConfirmMinerWorkerChange_Call {
	_c.Call.Return(run)
	return _c
}

// AgentCreate provides a mock function with given fields: ctx, auth, owner, operator, request
func (_m *FEVMActions) AgentCreate(ctx context.Context, auth *bind.TransactOpts, owner common.Address, operator common.Address, request common.Address) (*types.Transaction, error) {
	ret := _m.Called(ctx, auth, owner, operator, request)

	if len(ret) == 0 {
		panic("no return value specified for AgentCreate")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, common.Address, common.Address, common.Address) (*types.Transaction, error)); ok {
		return rf(ctx, auth, owner, operator, request)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, common.Address, common.Address, common.Address) *types.Transaction); ok {
		r0 = rf(ctx, auth, owner, operator, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.TransactOpts, common.Address, common.Address, common.Address) error); ok {
		r1 = rf(ctx, auth, owner, operator, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMActions_AgentCreate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentCreate'
type FEVMActions_AgentCreate_Call struct {
	*mock.Call
}

// AgentCreate is a helper method to define mock.On call
//   - ctx context.Context
//   - auth *bind.TransactOpts
//   - owner common.Address
//   - operator common.Address
//   - request common.Address
func (_e *FEVMActions_Expecter) AgentCreate(ctx interface{}, auth interface{}, owner interface{}, operator interface{}, request interface{}) *FEVMActions_AgentCreate_Call {
	return &FEVMActions_AgentCreate_Call{Call: _e.mock.On("AgentCreate", ctx, auth, owner, operator, request)}
}

func (_c *FEVMActions_AgentCreate_Call) Run(run func(ctx context.Context, auth *bind.TransactOpts, owner common.Address, operator common.Address, request common.Address)) *FEVMActions_AgentCreate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.TransactOpts), args[2].(common.Address), args[3].(common.Address), args[4].(common.Address))
	})
	return _c
}

func (_c *FEVMActions_AgentCreate_Call) Return(_a0 *types.Transaction, _a1 error) *FEVMActions_AgentCreate_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMActions_AgentCreate_Call) RunAndReturn(run func(context.Context, *bind.TransactOpts, common.Address, common.Address, common.Address) (*types.Transaction, error)) *FEVMActions_AgentCreate_Call {
	_c.Call.Return(run)
	return _c
}

// AgentPay provides a mock function with given fields: ctx, auth, agentAddr, poolID, amount, requesterKey
func (_m *FEVMActions) AgentPay(ctx context.Context, auth *bind.TransactOpts, agentAddr common.Address, poolID *big.Int, amount *big.Int, requesterKey *ecdsa.PrivateKey) (*types.Transaction, error) {
	ret := _m.Called(ctx, auth, agentAddr, poolID, amount, requesterKey)

	if len(ret) == 0 {
		panic("no return value specified for AgentPay")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, common.Address, *big.Int, *big.Int, *ecdsa.PrivateKey) (*types.Transaction, error)); ok {
		return rf(ctx, auth, agentAddr, poolID, amount, requesterKey)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, common.Address, *big.Int, *big.Int, *ecdsa.PrivateKey) *types.Transaction); ok {
		r0 = rf(ctx, auth, agentAddr, poolID, amount, requesterKey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.TransactOpts, common.Address, *big.Int, *big.Int, *ecdsa.PrivateKey) error); ok {
		r1 = rf(ctx, auth, agentAddr, poolID, amount, requesterKey)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMActions_AgentPay_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentPay'
type FEVMActions_AgentPay_Call struct {
	*mock.Call
}

// AgentPay is a helper method to define mock.On call
//   - ctx context.Context
//   - auth *bind.TransactOpts
//   - agentAddr common.Address
//   - poolID *big.Int
//   - amount *big.Int
//   - requesterKey *ecdsa.PrivateKey
func (_e *FEVMActions_Expecter) AgentPay(ctx interface{}, auth interface{}, agentAddr interface{}, poolID interface{}, amount interface{}, requesterKey interface{}) *FEVMActions_AgentPay_Call {
	return &FEVMActions_AgentPay_Call{Call: _e.mock.On("AgentPay", ctx, auth, agentAddr, poolID, amount, requesterKey)}
}

func (_c *FEVMActions_AgentPay_Call) Run(run func(ctx context.Context, auth *bind.TransactOpts, agentAddr common.Address, poolID *big.Int, amount *big.Int, requesterKey *ecdsa.PrivateKey)) *FEVMActions_AgentPay_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.TransactOpts), args[2].(common.Address), args[3].(*big.Int), args[4].(*big.Int), args[5].(*ecdsa.PrivateKey))
	})
	return _c
}

func (_c *FEVMActions_AgentPay_Call) Return(_a0 *types.Transaction, _a1 error) *FEVMActions_AgentPay_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMActions_AgentPay_Call) RunAndReturn(run func(context.Context, *bind.TransactOpts, common.Address, *big.Int, *big.Int, *ecdsa.PrivateKey) (*types.Transaction, error)) *FEVMActions_AgentPay_Call {
	_c.Call.Return(run)
	return _c
}

// AgentPullFunds provides a mock function with given fields: ctx, auth, agentAddr, amount, miner, requesterKey
func (_m *FEVMActions) AgentPullFunds(ctx context.Context, auth *bind.TransactOpts, agentAddr common.Address, amount *big.Int, miner address.Address, requesterKey *ecdsa.PrivateKey) (*types.Transaction, error) {
	ret := _m.Called(ctx, auth, agentAddr, amount, miner, requesterKey)

	if len(ret) == 0 {
		panic("no return value specified for AgentPullFunds")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, common.Address, *big.Int, address.Address, *ecdsa.PrivateKey) (*types.Transaction, error)); ok {
		return rf(ctx, auth, agentAddr, amount, miner, requesterKey)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, common.Address, *big.Int, address.Address, *ecdsa.PrivateKey) *types.Transaction); ok {
		r0 = rf(ctx, auth, agentAddr, amount, miner, requesterKey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.TransactOpts, common.Address, *big.Int, address.Address, *ecdsa.PrivateKey) error); ok {
		r1 = rf(ctx, auth, agentAddr, amount, miner, requesterKey)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMActions_AgentPullFunds_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentPullFunds'
type FEVMActions_AgentPullFunds_Call struct {
	*mock.Call
}

// AgentPullFunds is a helper method to define mock.On call
//   - ctx context.Context
//   - auth *bind.TransactOpts
//   - agentAddr common.Address
//   - amount *big.Int
//   - miner address.Address
//   - requesterKey *ecdsa.PrivateKey
func (_e *FEVMActions_Expecter) AgentPullFunds(ctx interface{}, auth interface{}, agentAddr interface{}, amount interface{}, miner interface{}, requesterKey interface{}) *FEVMActions_AgentPullFunds_Call {
	return &FEVMActions_AgentPullFunds_Call{Call: _e.mock.On("AgentPullFunds", ctx, auth, agentAddr, amount, miner, requesterKey)}
}

func (_c *FEVMActions_AgentPullFunds_Call) Run(run func(ctx context.Context, auth *bind.TransactOpts, agentAddr common.Address, amount *big.Int, miner address.Address, requesterKey *ecdsa.PrivateKey)) *FEVMActions_AgentPullFunds_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.TransactOpts), args[2].(common.Address), args[3].(*big.Int), args[4].(address.Address), args[5].(*ecdsa.PrivateKey))
	})
	return _c
}

func (_c *FEVMActions_AgentPullFunds_Call) Return(_a0 *types.Transaction, _a1 error) *FEVMActions_AgentPullFunds_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMActions_AgentPullFunds_Call) RunAndReturn(run func(context.Context, *bind.TransactOpts, common.Address, *big.Int, address.Address, *ecdsa.PrivateKey) (*types.Transaction, error)) *FEVMActions_AgentPullFunds_Call {
	_c.Call.Return(run)
	return _c
}

// AgentPushFunds provides a mock function with given fields: ctx, auth, agentAddr, amount, miner, requesterKey
func (_m *FEVMActions) AgentPushFunds(ctx context.Context, auth *bind.TransactOpts, agentAddr common.Address, amount *big.Int, miner address.Address, requesterKey *ecdsa.PrivateKey) (*types.Transaction, error) {
	ret := _m.Called(ctx, auth, agentAddr, amount, miner, requesterKey)

	if len(ret) == 0 {
		panic("no return value specified for AgentPushFunds")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, common.Address, *big.Int, address.Address, *ecdsa.PrivateKey) (*types.Transaction, error)); ok {
		return rf(ctx, auth, agentAddr, amount, miner, requesterKey)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, common.Address, *big.Int, address.Address, *ecdsa.PrivateKey) *types.Transaction); ok {
		r0 = rf(ctx, auth, agentAddr, amount, miner, requesterKey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.TransactOpts, common.Address, *big.Int, address.Address, *ecdsa.PrivateKey) error); ok {
		r1 = rf(ctx, auth, agentAddr, amount, miner, requesterKey)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMActions_AgentPushFunds_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentPushFunds'
type FEVMActions_AgentPushFunds_Call struct {
	*mock.Call
}

// AgentPushFunds is a helper method to define mock.On call
//   - ctx context.Context
//   - auth *bind.TransactOpts
//   - agentAddr common.Address
//   - amount *big.Int
//   - miner address.Address
//   - requesterKey *ecdsa.PrivateKey
func (_e *FEVMActions_Expecter) AgentPushFunds(ctx interface{}, auth interface{}, agentAddr interface{}, amount interface{}, miner interface{}, requesterKey interface{}) *FEVMActions_AgentPushFunds_Call {
	return &FEVMActions_AgentPushFunds_Call{Call: _e.mock.On("AgentPushFunds", ctx, auth, agentAddr, amount, miner, requesterKey)}
}

func (_c *FEVMActions_AgentPushFunds_Call) Run(run func(ctx context.Context, auth *bind.TransactOpts, agentAddr common.Address, amount *big.Int, miner address.Address, requesterKey *ecdsa.PrivateKey)) *FEVMActions_AgentPushFunds_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.TransactOpts), args[2].(common.Address), args[3].(*big.Int), args[4].(address.Address), args[5].(*ecdsa.PrivateKey))
	})
	return _c
}

func (_c *FEVMActions_AgentPushFunds_Call) Return(_a0 *types.Transaction, _a1 error) *FEVMActions_AgentPushFunds_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMActions_AgentPushFunds_Call) RunAndReturn(run func(context.Context, *bind.TransactOpts, common.Address, *big.Int, address.Address, *ecdsa.PrivateKey) (*types.Transaction, error)) *FEVMActions_AgentPushFunds_Call {
	_c.Call.Return(run)
	return _c
}

// AgentRefreshRoutes provides a mock function with given fields: ctx, auth, agentAddr
func (_m *FEVMActions) AgentRefreshRoutes(ctx context.Context, auth *bind.TransactOpts, agentAddr common.Address) (*types.Transaction, error) {
	ret := _m.Called(ctx, auth, agentAddr)

	if len(ret) == 0 {
		panic("no return value specified for AgentRefreshRoutes")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, common.Address) (*types.Transaction, error)); ok {
		return rf(ctx, auth, agentAddr)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, common.Address) *types.Transaction); ok {
		r0 = rf(ctx, auth, agentAddr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.TransactOpts, common.Address) error); ok {
		r1 = rf(ctx, auth, agentAddr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMActions_AgentRefreshRoutes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentRefreshRoutes'
type FEVMActions_AgentRefreshRoutes_Call struct {
	*mock.Call
}

// AgentRefreshRoutes is a helper method to define mock.On call
//   - ctx context.Context
//   - auth *bind.TransactOpts
//   - agentAddr common.Address
func (_e *FEVMActions_Expecter) AgentRefreshRoutes(ctx interface{}, auth interface{}, agentAddr interface{}) *FEVMActions_AgentRefreshRoutes_Call {
	return &FEVMActions_AgentRefreshRoutes_Call{Call: _e.mock.On("AgentRefreshRoutes", ctx, auth, agentAddr)}
}

func (_c *FEVMActions_AgentRefreshRoutes_Call) Run(run func(ctx context.Context, auth *bind.TransactOpts, agentAddr common.Address)) *FEVMActions_AgentRefreshRoutes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.TransactOpts), args[2].(common.Address))
	})
	return _c
}

func (_c *FEVMActions_AgentRefreshRoutes_Call) Return(_a0 *types.Transaction, _a1 error) *FEVMActions_AgentRefreshRoutes_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMActions_AgentRefreshRoutes_Call) RunAndReturn(run func(context.Context, *bind.TransactOpts, common.Address) (*types.Transaction, error)) *FEVMActions_AgentRefreshRoutes_Call {
	_c.Call.Return(run)
	return _c
}

// AgentRemoveMiner provides a mock function with given fields: ctx, auth, agentAddr, minerAddr, newOwnerAddr, requesterKey
func (_m *FEVMActions) AgentRemoveMiner(ctx context.Context, auth *bind.TransactOpts, agentAddr common.Address, minerAddr address.Address, newOwnerAddr address.Address, requesterKey *ecdsa.PrivateKey) (*types.Transaction, error) {
	ret := _m.Called(ctx, auth, agentAddr, minerAddr, newOwnerAddr, requesterKey)

	if len(ret) == 0 {
		panic("no return value specified for AgentRemoveMiner")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, common.Address, address.Address, address.Address, *ecdsa.PrivateKey) (*types.Transaction, error)); ok {
		return rf(ctx, auth, agentAddr, minerAddr, newOwnerAddr, requesterKey)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, common.Address, address.Address, address.Address, *ecdsa.PrivateKey) *types.Transaction); ok {
		r0 = rf(ctx, auth, agentAddr, minerAddr, newOwnerAddr, requesterKey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.TransactOpts, common.Address, address.Address, address.Address, *ecdsa.PrivateKey) error); ok {
		r1 = rf(ctx, auth, agentAddr, minerAddr, newOwnerAddr, requesterKey)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMActions_AgentRemoveMiner_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentRemoveMiner'
type FEVMActions_AgentRemoveMiner_Call struct {
	*mock.Call
}

// AgentRemoveMiner is a helper method to define mock.On call
//   - ctx context.Context
//   - auth *bind.TransactOpts
//   - agentAddr common.Address
//   - minerAddr address.Address
//   - newOwnerAddr address.Address
//   - requesterKey *ecdsa.PrivateKey
func (_e *FEVMActions_Expecter) AgentRemoveMiner(ctx interface{}, auth interface{}, agentAddr interface{}, minerAddr interface{}, newOwnerAddr interface{}, requesterKey interface{}) *FEVMActions_AgentRemoveMiner_Call {
	return &FEVMActions_AgentRemoveMiner_Call{Call: _e.mock.On("AgentRemoveMiner", ctx, auth, agentAddr, minerAddr, newOwnerAddr, requesterKey)}
}

func (_c *FEVMActions_AgentRemoveMiner_Call) Run(run func(ctx context.Context, auth *bind.TransactOpts, agentAddr common.Address, minerAddr address.Address, newOwnerAddr address.Address, requesterKey *ecdsa.PrivateKey)) *FEVMActions_AgentRemoveMiner_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.TransactOpts), args[2].(common.Address), args[3].(address.Address), args[4].(address.Address), args[5].(*ecdsa.PrivateKey))
	})
	return _c
}

func (_c *FEVMActions_AgentRemoveMiner_Call) Return(_a0 *types.Transaction, _a1 error) *FEVMActions_AgentRemoveMiner_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMActions_AgentRemoveMiner_Call) RunAndReturn(run func(context.Context, *bind.TransactOpts, common.Address, address.Address, address.Address, *ecdsa.PrivateKey) (*types.Transaction, error)) *FEVMActions_AgentRemoveMiner_Call {
	_c.Call.Return(run)
	return _c
}

// AgentSetRecovered provides a mock function with given fields: ctx, auth, agentAddr, requesterKey
func (_m *FEVMActions) AgentSetRecovered(ctx context.Context, auth *bind.TransactOpts, agentAddr common.Address, requesterKey *ecdsa.PrivateKey) (*types.Transaction, error) {
	ret := _m.Called(ctx, auth, agentAddr, requesterKey)

	if len(ret) == 0 {
		panic("no return value specified for AgentSetRecovered")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, common.Address, *ecdsa.PrivateKey) (*types.Transaction, error)); ok {
		return rf(ctx, auth, agentAddr, requesterKey)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, common.Address, *ecdsa.PrivateKey) *types.Transaction); ok {
		r0 = rf(ctx, auth, agentAddr, requesterKey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.TransactOpts, common.Address, *ecdsa.PrivateKey) error); ok {
		r1 = rf(ctx, auth, agentAddr, requesterKey)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMActions_AgentSetRecovered_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentSetRecovered'
type FEVMActions_AgentSetRecovered_Call struct {
	*mock.Call
}

// AgentSetRecovered is a helper method to define mock.On call
//   - ctx context.Context
//   - auth *bind.TransactOpts
//   - agentAddr common.Address
//   - requesterKey *ecdsa.PrivateKey
func (_e *FEVMActions_Expecter) AgentSetRecovered(ctx interface{}, auth interface{}, agentAddr interface{}, requesterKey interface{}) *FEVMActions_AgentSetRecovered_Call {
	return &FEVMActions_AgentSetRecovered_Call{Call: _e.mock.On("AgentSetRecovered", ctx, auth, agentAddr, requesterKey)}
}

func (_c *FEVMActions_AgentSetRecovered_Call) Run(run func(ctx context.Context, auth *bind.TransactOpts, agentAddr common.Address, requesterKey *ecdsa.PrivateKey)) *FEVMActions_AgentSetRecovered_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.TransactOpts), args[2].(common.Address), args[3].(*ecdsa.PrivateKey))
	})
	return _c
}

func (_c *FEVMActions_AgentSetRecovered_Call) Return(_a0 *types.Transaction, _a1 error) *FEVMActions_AgentSetRecovered_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMActions_AgentSetRecovered_Call) RunAndReturn(run func(context.Context, *bind.TransactOpts, common.Address, *ecdsa.PrivateKey) (*types.Transaction, error)) *FEVMActions_AgentSetRecovered_Call {
	_c.Call.Return(run)
	return _c
}

// AgentTransferOperator provides a mock function with given fields: ctx, auth, agentAddr, newOperator
func (_m *FEVMActions) AgentTransferOperator(ctx context.Context, auth *bind.TransactOpts, agentAddr common.Address, newOperator common.Address) (*types.Transaction, error) {
	ret := _m.Called(ctx, auth, agentAddr, newOperator)

	if len(ret) == 0 {
		panic("no return value specified for AgentTransferOperator")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, common.Address, common.Address) (*types.Transaction, error)); ok {
		return rf(ctx, auth, agentAddr, newOperator)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, common.Address, common.Address) *types.Transaction); ok {
		r0 = rf(ctx, auth, agentAddr, newOperator)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.TransactOpts, common.Address, common.Address) error); ok {
		r1 = rf(ctx, auth, agentAddr, newOperator)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMActions_AgentTransferOperator_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentTransferOperator'
type FEVMActions_AgentTransferOperator_Call struct {
	*mock.Call
}

// AgentTransferOperator is a helper method to define mock.On call
//   - ctx context.Context
//   - auth *bind.TransactOpts
//   - agentAddr common.Address
//   - newOperator common.Address
func (_e *FEVMActions_Expecter) AgentTransferOperator(ctx interface{}, auth interface{}, agentAddr interface{}, newOperator interface{}) *FEVMActions_AgentTransferOperator_Call {
	return &FEVMActions_AgentTransferOperator_Call{Call: _e.mock.On("AgentTransferOperator", ctx, auth, agentAddr, newOperator)}
}

func (_c *FEVMActions_AgentTransferOperator_Call) Run(run func(ctx context.Context, auth *bind.TransactOpts, agentAddr common.Address, newOperator common.Address)) *FEVMActions_AgentTransferOperator_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.TransactOpts), args[2].(common.Address), args[3].(common.Address))
	})
	return _c
}

func (_c *FEVMActions_AgentTransferOperator_Call) Return(_a0 *types.Transaction, _a1 error) *FEVMActions_AgentTransferOperator_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMActions_AgentTransferOperator_Call) RunAndReturn(run func(context.Context, *bind.TransactOpts, common.Address, common.Address) (*types.Transaction, error)) *FEVMActions_AgentTransferOperator_Call {
	_c.Call.Return(run)
	return _c
}

// AgentTransferOwnership provides a mock function with given fields: ctx, auth, agentAddr, newOwner
func (_m *FEVMActions) AgentTransferOwnership(ctx context.Context, auth *bind.TransactOpts, agentAddr common.Address, newOwner common.Address) (*types.Transaction, error) {
	ret := _m.Called(ctx, auth, agentAddr, newOwner)

	if len(ret) == 0 {
		panic("no return value specified for AgentTransferOwnership")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, common.Address, common.Address) (*types.Transaction, error)); ok {
		return rf(ctx, auth, agentAddr, newOwner)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, common.Address, common.Address) *types.Transaction); ok {
		r0 = rf(ctx, auth, agentAddr, newOwner)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.TransactOpts, common.Address, common.Address) error); ok {
		r1 = rf(ctx, auth, agentAddr, newOwner)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMActions_AgentTransferOwnership_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentTransferOwnership'
type FEVMActions_AgentTransferOwnership_Call struct {
	*mock.Call
}

// AgentTransferOwnership is a helper method to define mock.On call
//   - ctx context.Context
//   - auth *bind.TransactOpts
//   - agentAddr common.Address
//   - newOwner common.Address
func (_e *FEVMActions_Expecter) AgentTransferOwnership(ctx interface{}, auth interface{}, agentAddr interface{}, newOwner interface{}) *FEVMActions_AgentTransferOwnership_Call {
	return &FEVMActions_AgentTransferOwnership_Call{Call: _e.mock.On("AgentTransferOwnership", ctx, auth, agentAddr, newOwner)}
}

func (_c *FEVMActions_AgentTransferOwnership_Call) Run(run func(ctx context.Context, auth *bind.TransactOpts, agentAddr common.Address, newOwner common.Address)) *FEVMActions_AgentTransferOwnership_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.TransactOpts), args[2].(common.Address), args[3].(common.Address))
	})
	return _c
}

func (_c *FEVMActions_AgentTransferOwnership_Call) Return(_a0 *types.Transaction, _a1 error) *FEVMActions_AgentTransferOwnership_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMActions_AgentTransferOwnership_Call) RunAndReturn(run func(context.Context, *bind.TransactOpts, common.Address, common.Address) (*types.Transaction, error)) *FEVMActions_AgentTransferOwnership_Call {
	_c.Call.Return(run)
	return _c
}

// AgentWithdraw provides a mock function with given fields: ctx, auth, agentAddr, receiver, amount, requesterKey
func (_m *FEVMActions) AgentWithdraw(ctx context.Context, auth *bind.TransactOpts, agentAddr common.Address, receiver common.Address, amount *big.Int, requesterKey *ecdsa.PrivateKey) (*types.Transaction, error) {
	ret := _m.Called(ctx, auth, agentAddr, receiver, amount, requesterKey)

	if len(ret) == 0 {
		panic("no return value specified for AgentWithdraw")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, common.Address, common.Address, *big.Int, *ecdsa.PrivateKey) (*types.Transaction, error)); ok {
		return rf(ctx, auth, agentAddr, receiver, amount, requesterKey)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, common.Address, common.Address, *big.Int, *ecdsa.PrivateKey) *types.Transaction); ok {
		r0 = rf(ctx, auth, agentAddr, receiver, amount, requesterKey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.TransactOpts, common.Address, common.Address, *big.Int, *ecdsa.PrivateKey) error); ok {
		r1 = rf(ctx, auth, agentAddr, receiver, amount, requesterKey)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMActions_AgentWithdraw_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentWithdraw'
type FEVMActions_AgentWithdraw_Call struct {
	*mock.Call
}

// AgentWithdraw is a helper method to define mock.On call
//   - ctx context.Context
//   - auth *bind.TransactOpts
//   - agentAddr common.Address
//   - receiver common.Address
//   - amount *big.Int
//   - requesterKey *ecdsa.PrivateKey
func (_e *FEVMActions_Expecter) AgentWithdraw(ctx interface{}, auth interface{}, agentAddr interface{}, receiver interface{}, amount interface{}, requesterKey interface{}) *FEVMActions_AgentWithdraw_Call {
	return &FEVMActions_AgentWithdraw_Call{Call: _e.mock.On("AgentWithdraw", ctx, auth, agentAddr, receiver, amount, requesterKey)}
}

func (_c *FEVMActions_AgentWithdraw_Call) Run(run func(ctx context.Context, auth *bind.TransactOpts, agentAddr common.Address, receiver common.Address, amount *big.Int, requesterKey *ecdsa.PrivateKey)) *FEVMActions_AgentWithdraw_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.TransactOpts), args[2].(common.Address), args[3].(common.Address), args[4].(*big.Int), args[5].(*ecdsa.PrivateKey))
	})
	return _c
}

func (_c *FEVMActions_AgentWithdraw_Call) Return(_a0 *types.Transaction, _a1 error) *FEVMActions_AgentWithdraw_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMActions_AgentWithdraw_Call) RunAndReturn(run func(context.Context, *bind.TransactOpts, common.Address, common.Address, *big.Int, *ecdsa.PrivateKey) (*types.Transaction, error)) *FEVMActions_AgentWithdraw_Call {
	_c.Call.Return(run)
	return _c
}

// IFILApprove provides a mock function with given fields: ctx, auth, spender, allowance
func (_m *FEVMActions) IFILApprove(ctx context.Context, auth *bind.TransactOpts, spender common.Address, allowance *big.Int) (*types.Transaction, error) {
	ret := _m.Called(ctx, auth, spender, allowance)

	if len(ret) == 0 {
		panic("no return value specified for IFILApprove")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, common.Address, *big.Int) (*types.Transaction, error)); ok {
		return rf(ctx, auth, spender, allowance)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, common.Address, *big.Int) *types.Transaction); ok {
		r0 = rf(ctx, auth, spender, allowance)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.TransactOpts, common.Address, *big.Int) error); ok {
		r1 = rf(ctx, auth, spender, allowance)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMActions_IFILApprove_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IFILApprove'
type FEVMActions_IFILApprove_Call struct {
	*mock.Call
}

// IFILApprove is a helper method to define mock.On call
//   - ctx context.Context
//   - auth *bind.TransactOpts
//   - spender common.Address
//   - allowance *big.Int
func (_e *FEVMActions_Expecter) IFILApprove(ctx interface{}, auth interface{}, spender interface{}, allowance interface{}) *FEVMActions_IFILApprove_Call {
	return &FEVMActions_IFILApprove_Call{Call: _e.mock.On("IFILApprove", ctx, auth, spender, allowance)}
}

func (_c *FEVMActions_IFILApprove_Call) Run(run func(ctx context.Context, auth *bind.TransactOpts, spender common.Address, allowance *big.Int)) *FEVMActions_IFILApprove_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.TransactOpts), args[2].(common.Address), args[3].(*big.Int))
	})
	return _c
}

func (_c *FEVMActions_IFILApprove_Call) Return(_a0 *types.Transaction, _a1 error) *FEVMActions_IFILApprove_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMActions_IFILApprove_Call) RunAndReturn(run func(context.Context, *bind.TransactOpts, common.Address, *big.Int) (*types.Transaction, error)) *FEVMActions_IFILApprove_Call {
	_c.Call.Return(run)
	return _c
}

// IFILTransfer provides a mock function with given fields: ctx, auth, receiver, amount
func (_m *FEVMActions) IFILTransfer(ctx context.Context, auth *bind.TransactOpts, receiver common.Address, amount *big.Int) (*types.Transaction, error) {
	ret := _m.Called(ctx, auth, receiver, amount)

	if len(ret) == 0 {
		panic("no return value specified for IFILTransfer")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, common.Address, *big.Int) (*types.Transaction, error)); ok {
		return rf(ctx, auth, receiver, amount)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, common.Address, *big.Int) *types.Transaction); ok {
		r0 = rf(ctx, auth, receiver, amount)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.TransactOpts, common.Address, *big.Int) error); ok {
		r1 = rf(ctx, auth, receiver, amount)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMActions_IFILTransfer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IFILTransfer'
type FEVMActions_IFILTransfer_Call struct {
	*mock.Call
}

// IFILTransfer is a helper method to define mock.On call
//   - ctx context.Context
//   - auth *bind.TransactOpts
//   - receiver common.Address
//   - amount *big.Int
func (_e *FEVMActions_Expecter) IFILTransfer(ctx interface{}, auth interface{}, receiver interface{}, amount interface{}) *FEVMActions_IFILTransfer_Call {
	return &FEVMActions_IFILTransfer_Call{Call: _e.mock.On("IFILTransfer", ctx, auth, receiver, amount)}
}

func (_c *FEVMActions_IFILTransfer_Call) Run(run func(ctx context.Context, auth *bind.TransactOpts, receiver common.Address, amount *big.Int)) *FEVMActions_IFILTransfer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.TransactOpts), args[2].(common.Address), args[3].(*big.Int))
	})
	return _c
}

func (_c *FEVMActions_IFILTransfer_Call) Return(_a0 *types.Transaction, _a1 error) *FEVMActions_IFILTransfer_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMActions_IFILTransfer_Call) RunAndReturn(run func(context.Context, *bind.TransactOpts, common.Address, *big.Int) (*types.Transaction, error)) *FEVMActions_IFILTransfer_Call {
	_c.Call.Return(run)
	return _c
}

// InfPoolDepositFIL provides a mock function with given fields: ctx, auth, agentAddr, amount
func (_m *FEVMActions) InfPoolDepositFIL(ctx context.Context, auth *bind.TransactOpts, agentAddr common.Address, amount *big.Int) (*types.Transaction, error) {
	ret := _m.Called(ctx, auth, agentAddr, amount)

	if len(ret) == 0 {
		panic("no return value specified for InfPoolDepositFIL")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, common.Address, *big.Int) (*types.Transaction, error)); ok {
		return rf(ctx, auth, agentAddr, amount)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, common.Address, *big.Int) *types.Transaction); ok {
		r0 = rf(ctx, auth, agentAddr, amount)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.TransactOpts, common.Address, *big.Int) error); ok {
		r1 = rf(ctx, auth, agentAddr, amount)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMActions_InfPoolDepositFIL_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InfPoolDepositFIL'
type FEVMActions_InfPoolDepositFIL_Call struct {
	*mock.Call
}

// InfPoolDepositFIL is a helper method to define mock.On call
//   - ctx context.Context
//   - auth *bind.TransactOpts
//   - agentAddr common.Address
//   - amount *big.Int
func (_e *FEVMActions_Expecter) InfPoolDepositFIL(ctx interface{}, auth interface{}, agentAddr interface{}, amount interface{}) *FEVMActions_InfPoolDepositFIL_Call {
	return &FEVMActions_InfPoolDepositFIL_Call{Call: _e.mock.On("InfPoolDepositFIL", ctx, auth, agentAddr, amount)}
}

func (_c *FEVMActions_InfPoolDepositFIL_Call) Run(run func(ctx context.Context, auth *bind.TransactOpts, agentAddr common.Address, amount *big.Int)) *FEVMActions_InfPoolDepositFIL_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.TransactOpts), args[2].(common.Address), args[3].(*big.Int))
	})
	return _c
}

func (_c *FEVMActions_InfPoolDepositFIL_Call) Return(_a0 *types.Transaction, _a1 error) *FEVMActions_InfPoolDepositFIL_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMActions_InfPoolDepositFIL_Call) RunAndReturn(run func(context.Context, *bind.TransactOpts, common.Address, *big.Int) (*types.Transaction, error)) *FEVMActions_InfPoolDepositFIL_Call {
	_c.Call.Return(run)
	return _c
}

// InfPoolRedeem provides a mock function with given fields: ctx, auth, shares, sender, receiver
func (_m *FEVMActions) InfPoolRedeem(ctx context.Context, auth *bind.TransactOpts, shares *big.Int, sender common.Address, receiver common.Address) (*types.Transaction, error) {
	ret := _m.Called(ctx, auth, shares, sender, receiver)

	if len(ret) == 0 {
		panic("no return value specified for InfPoolRedeem")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, *big.Int, common.Address, common.Address) (*types.Transaction, error)); ok {
		return rf(ctx, auth, shares, sender, receiver)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, *big.Int, common.Address, common.Address) *types.Transaction); ok {
		r0 = rf(ctx, auth, shares, sender, receiver)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.TransactOpts, *big.Int, common.Address, common.Address) error); ok {
		r1 = rf(ctx, auth, shares, sender, receiver)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMActions_InfPoolRedeem_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InfPoolRedeem'
type FEVMActions_InfPoolRedeem_Call struct {
	*mock.Call
}

// InfPoolRedeem is a helper method to define mock.On call
//   - ctx context.Context
//   - auth *bind.TransactOpts
//   - shares *big.Int
//   - sender common.Address
//   - receiver common.Address
func (_e *FEVMActions_Expecter) InfPoolRedeem(ctx interface{}, auth interface{}, shares interface{}, sender interface{}, receiver interface{}) *FEVMActions_InfPoolRedeem_Call {
	return &FEVMActions_InfPoolRedeem_Call{Call: _e.mock.On("InfPoolRedeem", ctx, auth, shares, sender, receiver)}
}

func (_c *FEVMActions_InfPoolRedeem_Call) Run(run func(ctx context.Context, auth *bind.TransactOpts, shares *big.Int, sender common.Address, receiver common.Address)) *FEVMActions_InfPoolRedeem_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.TransactOpts), args[2].(*big.Int), args[3].(common.Address), args[4].(common.Address))
	})
	return _c
}

func (_c *FEVMActions_InfPoolRedeem_Call) Return(_a0 *types.Transaction, _a1 error) *FEVMActions_InfPoolRedeem_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMActions_InfPoolRedeem_Call) RunAndReturn(run func(context.Context, *bind.TransactOpts, *big.Int, common.Address, common.Address) (*types.Transaction, error)) *FEVMActions_InfPoolRedeem_Call {
	_c.Call.Return(run)
	return _c
}

// InfPoolWithdraw provides a mock function with given fields: ctx, auth, assets, sender, receiver
func (_m *FEVMActions) InfPoolWithdraw(ctx context.Context, auth *bind.TransactOpts, assets *big.Int, sender common.Address, receiver common.Address) (*types.Transaction, error) {
	ret := _m.Called(ctx, auth, assets, sender, receiver)

	if len(ret) == 0 {
		panic("no return value specified for InfPoolWithdraw")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, *big.Int, common.Address, common.Address) (*types.Transaction, error)); ok {
		return rf(ctx, auth, assets, sender, receiver)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, *big.Int, common.Address, common.Address) *types.Transaction); ok {
		r0 = rf(ctx, auth, assets, sender, receiver)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.TransactOpts, *big.Int, common.Address, common.Address) error); ok {
		r1 = rf(ctx, auth, assets, sender, receiver)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMActions_InfPoolWithdraw_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InfPoolWithdraw'
type FEVMActions_InfPoolWithdraw_Call struct {
	*mock.Call
}

// InfPoolWithdraw is a helper method to define mock.On call
//   - ctx context.Context
//   - auth *bind.TransactOpts
//   - assets *big.Int
//   - sender common.Address
//   - receiver common.Address
func (_e *FEVMActions_Expecter) InfPoolWithdraw(ctx interface{}, auth interface{}, assets interface{}, sender interface{}, receiver interface{}) *FEVMActions_InfPoolWithdraw_Call {
	return &FEVMActions_InfPoolWithdraw_Call{Call: _e.mock.On("InfPoolWithdraw", ctx, auth, assets, sender, receiver)}
}

func (_c *FEVMActions_InfPoolWithdraw_Call) Run(run func(ctx context.Context, auth *bind.TransactOpts, assets *big.Int, sender common.Address, receiver common.Address)) *FEVMActions_InfPoolWithdraw_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.TransactOpts), args[2].(*big.Int), args[3].(common.Address), args[4].(common.Address))
	})
	return _c
}

func (_c *FEVMActions_InfPoolWithdraw_Call) Return(_a0 *types.Transaction, _a1 error) *FEVMActions_InfPoolWithdraw_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMActions_InfPoolWithdraw_Call) RunAndReturn(run func(context.Context, *bind.TransactOpts, *big.Int, common.Address, common.Address) (*types.Transaction, error)) *FEVMActions_InfPoolWithdraw_Call {
	_c.Call.Return(run)
	return _c
}

// SPPlusActivate provides a mock function with given fields: ctx, auth, beneficiary, tokenID, tier
func (_m *FEVMActions) SPPlusActivate(ctx context.Context, auth *bind.TransactOpts, beneficiary common.Address, tokenID *big.Int, tier uint8) (*types.Transaction, error) {
	ret := _m.Called(ctx, auth, beneficiary, tokenID, tier)

	if len(ret) == 0 {
		panic("no return value specified for SPPlusActivate")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, common.Address, *big.Int, uint8) (*types.Transaction, error)); ok {
		return rf(ctx, auth, beneficiary, tokenID, tier)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, common.Address, *big.Int, uint8) *types.Transaction); ok {
		r0 = rf(ctx, auth, beneficiary, tokenID, tier)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.TransactOpts, common.Address, *big.Int, uint8) error); ok {
		r1 = rf(ctx, auth, beneficiary, tokenID, tier)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMActions_SPPlusActivate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SPPlusActivate'
type FEVMActions_SPPlusActivate_Call struct {
	*mock.Call
}

// SPPlusActivate is a helper method to define mock.On call
//   - ctx context.Context
//   - auth *bind.TransactOpts
//   - beneficiary common.Address
//   - tokenID *big.Int
//   - tier uint8
func (_e *FEVMActions_Expecter) SPPlusActivate(ctx interface{}, auth interface{}, beneficiary interface{}, tokenID interface{}, tier interface{}) *FEVMActions_SPPlusActivate_Call {
	return &FEVMActions_SPPlusActivate_Call{Call: _e.mock.On("SPPlusActivate", ctx, auth, beneficiary, tokenID, tier)}
}

func (_c *FEVMActions_SPPlusActivate_Call) Run(run func(ctx context.Context, auth *bind.TransactOpts, beneficiary common.Address, tokenID *big.Int, tier uint8)) *FEVMActions_SPPlusActivate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.TransactOpts), args[2].(common.Address), args[3].(*big.Int), args[4].(uint8))
	})
	return _c
}

func (_c *FEVMActions_SPPlusActivate_Call) Return(_a0 *types.Transaction, _a1 error) *FEVMActions_SPPlusActivate_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMActions_SPPlusActivate_Call) RunAndReturn(run func(context.Context, *bind.TransactOpts, common.Address, *big.Int, uint8) (*types.Transaction, error)) *FEVMActions_SPPlusActivate_Call {
	_c.Call.Return(run)
	return _c
}

// SPPlusClaimCashBack provides a mock function with given fields: ctx, auth, tokenID, receiver
func (_m *FEVMActions) SPPlusClaimCashBack(ctx context.Context, auth *bind.TransactOpts, tokenID *big.Int, receiver common.Address) (*types.Transaction, error) {
	ret := _m.Called(ctx, auth, tokenID, receiver)

	if len(ret) == 0 {
		panic("no return value specified for SPPlusClaimCashBack")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, *big.Int, common.Address) (*types.Transaction, error)); ok {
		return rf(ctx, auth, tokenID, receiver)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, *big.Int, common.Address) *types.Transaction); ok {
		r0 = rf(ctx, auth, tokenID, receiver)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.TransactOpts, *big.Int, common.Address) error); ok {
		r1 = rf(ctx, auth, tokenID, receiver)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMActions_SPPlusClaimCashBack_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SPPlusClaimCashBack'
type FEVMActions_SPPlusClaimCashBack_Call struct {
	*mock.Call
}

// SPPlusClaimCashBack is a helper method to define mock.On call
//   - ctx context.Context
//   - auth *bind.TransactOpts
//   - tokenID *big.Int
//   - receiver common.Address
func (_e *FEVMActions_Expecter) SPPlusClaimCashBack(ctx interface{}, auth interface{}, tokenID interface{}, receiver interface{}) *FEVMActions_SPPlusClaimCashBack_Call {
	return &FEVMActions_SPPlusClaimCashBack_Call{Call: _e.mock.On("SPPlusClaimCashBack", ctx, auth, tokenID, receiver)}
}

func (_c *FEVMActions_SPPlusClaimCashBack_Call) Run(run func(ctx context.Context, auth *bind.TransactOpts, tokenID *big.Int, receiver common.Address)) *FEVMActions_SPPlusClaimCashBack_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.TransactOpts), args[2].(*big.Int), args[3].(common.Address))
	})
	return _c
}

func (_c *FEVMActions_SPPlusClaimCashBack_Call) Return(_a0 *types.Transaction, _a1 error) *FEVMActions_SPPlusClaimCashBack_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMActions_SPPlusClaimCashBack_Call) RunAndReturn(run func(context.Context, *bind.TransactOpts, *big.Int, common.Address) (*types.Transaction, error)) *FEVMActions_SPPlusClaimCashBack_Call {
	_c.Call.Return(run)
	return _c
}

// SPPlusDowngrade provides a mock function with given fields: ctx, auth, tokenID, tier, agentAddr, requesterKey
func (_m *FEVMActions) SPPlusDowngrade(ctx context.Context, auth *bind.TransactOpts, tokenID *big.Int, tier uint8, agentAddr common.Address, requesterKey *ecdsa.PrivateKey) (*types.Transaction, error) {
	ret := _m.Called(ctx, auth, tokenID, tier, agentAddr, requesterKey)

	if len(ret) == 0 {
		panic("no return value specified for SPPlusDowngrade")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, *big.Int, uint8, common.Address, *ecdsa.PrivateKey) (*types.Transaction, error)); ok {
		return rf(ctx, auth, tokenID, tier, agentAddr, requesterKey)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, *big.Int, uint8, common.Address, *ecdsa.PrivateKey) *types.Transaction); ok {
		r0 = rf(ctx, auth, tokenID, tier, agentAddr, requesterKey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.TransactOpts, *big.Int, uint8, common.Address, *ecdsa.PrivateKey) error); ok {
		r1 = rf(ctx, auth, tokenID, tier, agentAddr, requesterKey)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMActions_SPPlusDowngrade_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SPPlusDowngrade'
type FEVMActions_SPPlusDowngrade_Call struct {
	*mock.Call
}

// SPPlusDowngrade is a helper method to define mock.On call
//   - ctx context.Context
//   - auth *bind.TransactOpts
//   - tokenID *big.Int
//   - tier uint8
//   - agentAddr common.Address
//   - requesterKey *ecdsa.PrivateKey
func (_e *FEVMActions_Expecter) SPPlusDowngrade(ctx interface{}, auth interface{}, tokenID interface{}, tier interface{}, agentAddr interface{}, requesterKey interface{}) *FEVMActions_SPPlusDowngrade_Call {
	return &FEVMActions_SPPlusDowngrade_Call{Call: _e.mock.On("SPPlusDowngrade", ctx, auth, tokenID, tier, agentAddr, requesterKey)}
}

func (_c *FEVMActions_SPPlusDowngrade_Call) Run(run func(ctx context.Context, auth *bind.TransactOpts, tokenID *big.Int, tier uint8, agentAddr common.Address, requesterKey *ecdsa.PrivateKey)) *FEVMActions_SPPlusDowngrade_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.TransactOpts), args[2].(*big.Int), args[3].(uint8), args[4].(common.Address), args[5].(*ecdsa.PrivateKey))
	})
	return _c
}

func (_c *FEVMActions_SPPlusDowngrade_Call) Return(_a0 *types.Transaction, _a1 error) *FEVMActions_SPPlusDowngrade_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMActions_SPPlusDowngrade_Call) RunAndReturn(run func(context.Context, *bind.TransactOpts, *big.Int, uint8, common.Address, *ecdsa.PrivateKey) (*types.Transaction, error)) *FEVMActions_SPPlusDowngrade_Call {
	_c.Call.Return(run)
	return _c
}

// SPPlusFundGLFVault provides a mock function with given fields: ctx, auth, tokenID, amount
func (_m *FEVMActions) SPPlusFundGLFVault(ctx context.Context, auth *bind.TransactOpts, tokenID *big.Int, amount *big.Int) (*types.Transaction, error) {
	ret := _m.Called(ctx, auth, tokenID, amount)

	if len(ret) == 0 {
		panic("no return value specified for SPPlusFundGLFVault")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, *big.Int, *big.Int) (*types.Transaction, error)); ok {
		return rf(ctx, auth, tokenID, amount)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, *big.Int, *big.Int) *types.Transaction); ok {
		r0 = rf(ctx, auth, tokenID, amount)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.TransactOpts, *big.Int, *big.Int) error); ok {
		r1 = rf(ctx, auth, tokenID, amount)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMActions_SPPlusFundGLFVault_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SPPlusFundGLFVault'
type FEVMActions_SPPlusFundGLFVault_Call struct {
	*mock.Call
}

// SPPlusFundGLFVault is a helper method to define mock.On call
//   - ctx context.Context
//   - auth *bind.TransactOpts
//   - tokenID *big.Int
//   - amount *big.Int
func (_e *FEVMActions_Expecter) SPPlusFundGLFVault(ctx interface{}, auth interface{}, tokenID interface{}, amount interface{}) *FEVMActions_SPPlusFundGLFVault_Call {
	return &FEVMActions_SPPlusFundGLFVault_Call{Call: _e.mock.On("SPPlusFundGLFVault", ctx, auth, tokenID, amount)}
}

func (_c *FEVMActions_SPPlusFundGLFVault_Call) Run(run func(ctx context.Context, auth *bind.TransactOpts, tokenID *big.Int, amount *big.Int)) *FEVMActions_SPPlusFundGLFVault_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.TransactOpts), args[2].(*big.Int), args[3].(*big.Int))
	})
	return _c
}

func (_c *FEVMActions_SPPlusFundGLFVault_Call) Return(_a0 *types.Transaction, _a1 error) *FEVMActions_SPPlusFundGLFVault_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMActions_SPPlusFundGLFVault_Call) RunAndReturn(run func(context.Context, *bind.TransactOpts, *big.Int, *big.Int) (*types.Transaction, error)) *FEVMActions_SPPlusFundGLFVault_Call {
	_c.Call.Return(run)
	return _c
}

// SPPlusMint provides a mock function with given fields: ctx, auth
func (_m *FEVMActions) SPPlusMint(ctx context.Context, auth *bind.TransactOpts) (*types.Transaction, error) {
	ret := _m.Called(ctx, auth)

	if len(ret) == 0 {
		panic("no return value specified for SPPlusMint")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts) (*types.Transaction, error)); ok {
		return rf(ctx, auth)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts) *types.Transaction); ok {
		r0 = rf(ctx, auth)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.TransactOpts) error); ok {
		r1 = rf(ctx, auth)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMActions_SPPlusMint_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SPPlusMint'
type FEVMActions_SPPlusMint_Call struct {
	*mock.Call
}

// SPPlusMint is a helper method to define mock.On call
//   - ctx context.Context
//   - auth *bind.TransactOpts
func (_e *FEVMActions_Expecter) SPPlusMint(ctx interface{}, auth interface{}) *FEVMActions_SPPlusMint_Call {
	return &FEVMActions_SPPlusMint_Call{Call: _e.mock.On("SPPlusMint", ctx, auth)}
}

func (_c *FEVMActions_SPPlusMint_Call) Run(run func(ctx context.Context, auth *bind.TransactOpts)) *FEVMActions_SPPlusMint_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.TransactOpts))
	})
	return _c
}

func (_c *FEVMActions_SPPlusMint_Call) Return(_a0 *types.Transaction, _a1 error) *FEVMActions_SPPlusMint_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMActions_SPPlusMint_Call) RunAndReturn(run func(context.Context, *bind.TransactOpts) (*types.Transaction, error)) *FEVMActions_SPPlusMint_Call {
	_c.Call.Return(run)
	return _c
}

// SPPlusMintActivateAndFund provides a mock function with given fields: ctx, auth, cashBackPercent, beneficiary, tier, amount
func (_m *FEVMActions) SPPlusMintActivateAndFund(ctx context.Context, auth *bind.TransactOpts, cashBackPercent *big.Int, beneficiary common.Address, tier uint8, amount *big.Int) (*types.Transaction, error) {
	ret := _m.Called(ctx, auth, cashBackPercent, beneficiary, tier, amount)

	if len(ret) == 0 {
		panic("no return value specified for SPPlusMintActivateAndFund")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, *big.Int, common.Address, uint8, *big.Int) (*types.Transaction, error)); ok {
		return rf(ctx, auth, cashBackPercent, beneficiary, tier, amount)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, *big.Int, common.Address, uint8, *big.Int) *types.Transaction); ok {
		r0 = rf(ctx, auth, cashBackPercent, beneficiary, tier, amount)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.TransactOpts, *big.Int, common.Address, uint8, *big.Int) error); ok {
		r1 = rf(ctx, auth, cashBackPercent, beneficiary, tier, amount)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMActions_SPPlusMintActivateAndFund_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SPPlusMintActivateAndFund'
type FEVMActions_SPPlusMintActivateAndFund_Call struct {
	*mock.Call
}

// SPPlusMintActivateAndFund is a helper method to define mock.On call
//   - ctx context.Context
//   - auth *bind.TransactOpts
//   - cashBackPercent *big.Int
//   - beneficiary common.Address
//   - tier uint8
//   - amount *big.Int
func (_e *FEVMActions_Expecter) SPPlusMintActivateAndFund(ctx interface{}, auth interface{}, cashBackPercent interface{}, beneficiary interface{}, tier interface{}, amount interface{}) *FEVMActions_SPPlusMintActivateAndFund_Call {
	return &FEVMActions_SPPlusMintActivateAndFund_Call{Call: _e.mock.On("SPPlusMintActivateAndFund", ctx, auth, cashBackPercent, beneficiary, tier, amount)}
}

func (_c *FEVMActions_SPPlusMintActivateAndFund_Call) Run(run func(ctx context.Context, auth *bind.TransactOpts, cashBackPercent *big.Int, beneficiary common.Address, tier uint8, amount *big.Int)) *FEVMActions_SPPlusMintActivateAndFund_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.TransactOpts), args[2].(*big.Int), args[3].(common.Address), args[4].(uint8), args[5].(*big.Int))
	})
	return _c
}

func (_c *FEVMActions_SPPlusMintActivateAndFund_Call) Return(_a0 *types.Transaction, _a1 error) *FEVMActions_SPPlusMintActivateAndFund_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMActions_SPPlusMintActivateAndFund_Call) RunAndReturn(run func(context.Context, *bind.TransactOpts, *big.Int, common.Address, uint8, *big.Int) (*types.Transaction, error)) *FEVMActions_SPPlusMintActivateAndFund_Call {
	_c.Call.Return(run)
	return _c
}

// SPPlusMintAndActivate provides a mock function with given fields: ctx, auth, beneficiary, tier
func (_m *FEVMActions) SPPlusMintAndActivate(ctx context.Context, auth *bind.TransactOpts, beneficiary common.Address, tier uint8) (*types.Transaction, error) {
	ret := _m.Called(ctx, auth, beneficiary, tier)

	if len(ret) == 0 {
		panic("no return value specified for SPPlusMintAndActivate")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, common.Address, uint8) (*types.Transaction, error)); ok {
		return rf(ctx, auth, beneficiary, tier)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, common.Address, uint8) *types.Transaction); ok {
		r0 = rf(ctx, auth, beneficiary, tier)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.TransactOpts, common.Address, uint8) error); ok {
		r1 = rf(ctx, auth, beneficiary, tier)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMActions_SPPlusMintAndActivate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SPPlusMintAndActivate'
type FEVMActions_SPPlusMintAndActivate_Call struct {
	*mock.Call
}

// SPPlusMintAndActivate is a helper method to define mock.On call
//   - ctx context.Context
//   - auth *bind.TransactOpts
//   - beneficiary common.Address
//   - tier uint8
func (_e *FEVMActions_Expecter) SPPlusMintAndActivate(ctx interface{}, auth interface{}, beneficiary interface{}, tier interface{}) *FEVMActions_SPPlusMintAndActivate_Call {
	return &FEVMActions_SPPlusMintAndActivate_Call{Call: _e.mock.On("SPPlusMintAndActivate", ctx, auth, beneficiary, tier)}
}

func (_c *FEVMActions_SPPlusMintAndActivate_Call) Run(run func(ctx context.Context, auth *bind.TransactOpts, beneficiary common.Address, tier uint8)) *FEVMActions_SPPlusMintAndActivate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.TransactOpts), args[2].(common.Address), args[3].(uint8))
	})
	return _c
}

func (_c *FEVMActions_SPPlusMintAndActivate_Call) Return(_a0 *types.Transaction, _a1 error) *FEVMActions_SPPlusMintAndActivate_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMActions_SPPlusMintAndActivate_Call) RunAndReturn(run func(context.Context, *bind.TransactOpts, common.Address, uint8) (*types.Transaction, error)) *FEVMActions_SPPlusMintAndActivate_Call {
	_c.Call.Return(run)
	return _c
}

// SPPlusSetPersonalCashBackPercent provides a mock function with given fields: ctx, auth, tokenID, cashBackPercent
func (_m *FEVMActions) SPPlusSetPersonalCashBackPercent(ctx context.Context, auth *bind.TransactOpts, tokenID *big.Int, cashBackPercent *big.Int) (*types.Transaction, error) {
	ret := _m.Called(ctx, auth, tokenID, cashBackPercent)

	if len(ret) == 0 {
		panic("no return value specified for SPPlusSetPersonalCashBackPercent")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, *big.Int, *big.Int) (*types.Transaction, error)); ok {
		return rf(ctx, auth, tokenID, cashBackPercent)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, *big.Int, *big.Int) *types.Transaction); ok {
		r0 = rf(ctx, auth, tokenID, cashBackPercent)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.TransactOpts, *big.Int, *big.Int) error); ok {
		r1 = rf(ctx, auth, tokenID, cashBackPercent)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMActions_SPPlusSetPersonalCashBackPercent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SPPlusSetPersonalCashBackPercent'
type FEVMActions_SPPlusSetPersonalCashBackPercent_Call struct {
	*mock.Call
}

// SPPlusSetPersonalCashBackPercent is a helper method to define mock.On call
//   - ctx context.Context
//   - auth *bind.TransactOpts
//   - tokenID *big.Int
//   - cashBackPercent *big.Int
func (_e *FEVMActions_Expecter) SPPlusSetPersonalCashBackPercent(ctx interface{}, auth interface{}, tokenID interface{}, cashBackPercent interface{}) *FEVMActions_SPPlusSetPersonalCashBackPercent_Call {
	return &FEVMActions_SPPlusSetPersonalCashBackPercent_Call{Call: _e.mock.On("SPPlusSetPersonalCashBackPercent", ctx, auth, tokenID, cashBackPercent)}
}

func (_c *FEVMActions_SPPlusSetPersonalCashBackPercent_Call) Run(run func(ctx context.Context, auth *bind.TransactOpts, tokenID *big.Int, cashBackPercent *big.Int)) *FEVMActions_SPPlusSetPersonalCashBackPercent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.TransactOpts), args[2].(*big.Int), args[3].(*big.Int))
	})
	return _c
}

func (_c *FEVMActions_SPPlusSetPersonalCashBackPercent_Call) Return(_a0 *types.Transaction, _a1 error) *FEVMActions_SPPlusSetPersonalCashBackPercent_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMActions_SPPlusSetPersonalCashBackPercent_Call) RunAndReturn(run func(context.Context, *bind.TransactOpts, *big.Int, *big.Int) (*types.Transaction, error)) *FEVMActions_SPPlusSetPersonalCashBackPercent_Call {
	_c.Call.Return(run)
	return _c
}

// SPPlusUpgrade provides a mock function with given fields: ctx, auth, tokenID, tier
func (_m *FEVMActions) SPPlusUpgrade(ctx context.Context, auth *bind.TransactOpts, tokenID *big.Int, tier uint8) (*types.Transaction, error) {
	ret := _m.Called(ctx, auth, tokenID, tier)

	if len(ret) == 0 {
		panic("no return value specified for SPPlusUpgrade")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, *big.Int, uint8) (*types.Transaction, error)); ok {
		return rf(ctx, auth, tokenID, tier)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, *big.Int, uint8) *types.Transaction); ok {
		r0 = rf(ctx, auth, tokenID, tier)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.TransactOpts, *big.Int, uint8) error); ok {
		r1 = rf(ctx, auth, tokenID, tier)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMActions_SPPlusUpgrade_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SPPlusUpgrade'
type FEVMActions_SPPlusUpgrade_Call struct {
	*mock.Call
}

// SPPlusUpgrade is a helper method to define mock.On call
//   - ctx context.Context
//   - auth *bind.TransactOpts
//   - tokenID *big.Int
//   - tier uint8
func (_e *FEVMActions_Expecter) SPPlusUpgrade(ctx interface{}, auth interface{}, tokenID interface{}, tier interface{}) *FEVMActions_SPPlusUpgrade_Call {
	return &FEVMActions_SPPlusUpgrade_Call{Call: _e.mock.On("SPPlusUpgrade", ctx, auth, tokenID, tier)}
}

func (_c *FEVMActions_SPPlusUpgrade_Call) Run(run func(ctx context.Context, auth *bind.TransactOpts, tokenID *big.Int, tier uint8)) *FEVMActions_SPPlusUpgrade_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.TransactOpts), args[2].(*big.Int), args[3].(uint8))
	})
	return _c
}

func (_c *FEVMActions_SPPlusUpgrade_Call) Return(_a0 *types.Transaction, _a1 error) *FEVMActions_SPPlusUpgrade_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMActions_SPPlusUpgrade_Call) RunAndReturn(run func(context.Context, *bind.TransactOpts, *big.Int, uint8) (*types.Transaction, error)) *FEVMActions_SPPlusUpgrade_Call {
	_c.Call.Return(run)
	return _c
}

// SPPlusWithdrawExtraLockedFunds provides a mock function with given fields: ctx, auth, tokenID
func (_m *FEVMActions) SPPlusWithdrawExtraLockedFunds(ctx context.Context, auth *bind.TransactOpts, tokenID *big.Int) (*types.Transaction, error) {
	ret := _m.Called(ctx, auth, tokenID)

	if len(ret) == 0 {
		panic("no return value specified for SPPlusWithdrawExtraLockedFunds")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, *big.Int) (*types.Transaction, error)); ok {
		return rf(ctx, auth, tokenID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.TransactOpts, *big.Int) *types.Transaction); ok {
		r0 = rf(ctx, auth, tokenID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.TransactOpts, *big.Int) error); ok {
		r1 = rf(ctx, auth, tokenID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMActions_SPPlusWithdrawExtraLockedFunds_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SPPlusWithdrawExtraLockedFunds'
type FEVMActions_SPPlusWithdrawExtraLockedFunds_Call struct {
	*mock.Call
}

// SPPlusWithdrawExtraLockedFunds is a helper method to define mock.On call
//   - ctx context.Context
//   - auth *bind.TransactOpts
//   - tokenID *big.Int
func (_e *FEVMActions_Expecter) SPPlusWithdrawExtraLockedFunds(ctx interface{}, auth interface{}, tokenID interface{}) *FEVMActions_SPPlusWithdrawExtraLockedFunds_Call {
	return &FEVMActions_SPPlusWithdrawExtraLockedFunds_Call{Call: _e.mock.On("SPPlusWithdrawExtraLockedFunds", ctx, auth, tokenID)}
}

func (_c *FEVMActions_SPPlusWithdrawExtraLockedFunds_Call) Run(run func(ctx context.Context, auth *bind.TransactOpts, tokenID *big.Int)) *FEVMActions_SPPlusWithdrawExtraLockedFunds_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.TransactOpts), args[2].(*big.Int))
	})
	return _c
}

func (_c *FEVMActions_SPPlusWithdrawExtraLockedFunds_Call) Return(_a0 *types.Transaction, _a1 error) *FEVMActions_SPPlusWithdrawExtraLockedFunds_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMActions_SPPlusWithdrawExtraLockedFunds_Call) RunAndReturn(run func(context.Context, *bind.TransactOpts, *big.Int) (*types.Transaction, error)) *FEVMActions_SPPlusWithdrawExtraLockedFunds_Call {
	_c.Call.Return(run)
	return _c
}

// NewFEVMActions creates a new instance of FEVMActions. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewFEVMActions(t interface {
	mock.TestingT
	Cleanup(func())
}) *FEVMActions {
	mock := &FEVMActions{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
