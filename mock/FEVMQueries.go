// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mock

import (
	address "github.com/filecoin-project/go-address"
	abigen "github.com/glifio/go-pools/abigen"

	big "math/big"

	chaintypes "github.com/filecoin-project/lotus/chain/types"

	common "github.com/ethereum/go-ethereum/common"

	constants "github.com/glifio/go-pools/constants"

	context "context"

	coretypes "github.com/ethereum/go-ethereum/core/types"

	mock "github.com/stretchr/testify/mock"
)

// FEVMQueries is an autogenerated mock type for the FEVMQueries type
type FEVMQueries struct {
	mock.Mock
}

type FEVMQueries_Expecter struct {
	mock *mock.Mock
}

func (_m *FEVMQueries) EXPECT() *FEVMQueries_Expecter {
	return &FEVMQueries_Expecter{mock: &_m.Mock}
}

// AgentAccount provides a mock function with given fields: ctx, agentAddr, poolID
func (_m *FEVMQueries) AgentAccount(ctx context.Context, agentAddr common.Address, poolID *big.Int) (abigen.Account, error) {
	ret := _m.Called(ctx, agentAddr, poolID)

	var r0 abigen.Account
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Address, *big.Int) (abigen.Account, error)); ok {
		return rf(ctx, agentAddr, poolID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Address, *big.Int) abigen.Account); ok {
		r0 = rf(ctx, agentAddr, poolID)
	} else {
		r0 = ret.Get(0).(abigen.Account)
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Address, *big.Int) error); ok {
		r1 = rf(ctx, agentAddr, poolID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_AgentAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentAccount'
type FEVMQueries_AgentAccount_Call struct {
	*mock.Call
}

// AgentAccount is a helper method to define mock.On call
//   - ctx context.Context
//   - agentAddr common.Address
//   - poolID *big.Int
func (_e *FEVMQueries_Expecter) AgentAccount(ctx interface{}, agentAddr interface{}, poolID interface{}) *FEVMQueries_AgentAccount_Call {
	return &FEVMQueries_AgentAccount_Call{Call: _e.mock.On("AgentAccount", ctx, agentAddr, poolID)}
}

func (_c *FEVMQueries_AgentAccount_Call) Run(run func(ctx context.Context, agentAddr common.Address, poolID *big.Int)) *FEVMQueries_AgentAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Address), args[2].(*big.Int))
	})
	return _c
}

func (_c *FEVMQueries_AgentAccount_Call) Return(_a0 abigen.Account, _a1 error) *FEVMQueries_AgentAccount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_AgentAccount_Call) RunAndReturn(run func(context.Context, common.Address, *big.Int) (abigen.Account, error)) *FEVMQueries_AgentAccount_Call {
	_c.Call.Return(run)
	return _c
}

// AgentAddrIDFromRcpt provides a mock function with given fields: ctx, rcpt
func (_m *FEVMQueries) AgentAddrIDFromRcpt(ctx context.Context, rcpt *coretypes.Receipt) (common.Address, *big.Int, error) {
	ret := _m.Called(ctx, rcpt)

	var r0 common.Address
	var r1 *big.Int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, *coretypes.Receipt) (common.Address, *big.Int, error)); ok {
		return rf(ctx, rcpt)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *coretypes.Receipt) common.Address); ok {
		r0 = rf(ctx, rcpt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *coretypes.Receipt) *big.Int); ok {
		r1 = rf(ctx, rcpt)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*big.Int)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, *coretypes.Receipt) error); ok {
		r2 = rf(ctx, rcpt)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// FEVMQueries_AgentAddrIDFromRcpt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentAddrIDFromRcpt'
type FEVMQueries_AgentAddrIDFromRcpt_Call struct {
	*mock.Call
}

// AgentAddrIDFromRcpt is a helper method to define mock.On call
//   - ctx context.Context
//   - rcpt *coretypes.Receipt
func (_e *FEVMQueries_Expecter) AgentAddrIDFromRcpt(ctx interface{}, rcpt interface{}) *FEVMQueries_AgentAddrIDFromRcpt_Call {
	return &FEVMQueries_AgentAddrIDFromRcpt_Call{Call: _e.mock.On("AgentAddrIDFromRcpt", ctx, rcpt)}
}

func (_c *FEVMQueries_AgentAddrIDFromRcpt_Call) Run(run func(ctx context.Context, rcpt *coretypes.Receipt)) *FEVMQueries_AgentAddrIDFromRcpt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*coretypes.Receipt))
	})
	return _c
}

func (_c *FEVMQueries_AgentAddrIDFromRcpt_Call) Return(_a0 common.Address, _a1 *big.Int, _a2 error) *FEVMQueries_AgentAddrIDFromRcpt_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *FEVMQueries_AgentAddrIDFromRcpt_Call) RunAndReturn(run func(context.Context, *coretypes.Receipt) (common.Address, *big.Int, error)) *FEVMQueries_AgentAddrIDFromRcpt_Call {
	_c.Call.Return(run)
	return _c
}

// AgentAdministrator provides a mock function with given fields: ctx, agentAddr
func (_m *FEVMQueries) AgentAdministrator(ctx context.Context, agentAddr common.Address) (common.Address, error) {
	ret := _m.Called(ctx, agentAddr)

	var r0 common.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) (common.Address, error)); ok {
		return rf(ctx, agentAddr)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) common.Address); ok {
		r0 = rf(ctx, agentAddr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Address) error); ok {
		r1 = rf(ctx, agentAddr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_AgentAdministrator_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentAdministrator'
type FEVMQueries_AgentAdministrator_Call struct {
	*mock.Call
}

// AgentAdministrator is a helper method to define mock.On call
//   - ctx context.Context
//   - agentAddr common.Address
func (_e *FEVMQueries_Expecter) AgentAdministrator(ctx interface{}, agentAddr interface{}) *FEVMQueries_AgentAdministrator_Call {
	return &FEVMQueries_AgentAdministrator_Call{Call: _e.mock.On("AgentAdministrator", ctx, agentAddr)}
}

func (_c *FEVMQueries_AgentAdministrator_Call) Run(run func(ctx context.Context, agentAddr common.Address)) *FEVMQueries_AgentAdministrator_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Address))
	})
	return _c
}

func (_c *FEVMQueries_AgentAdministrator_Call) Return(_a0 common.Address, _a1 error) *FEVMQueries_AgentAdministrator_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_AgentAdministrator_Call) RunAndReturn(run func(context.Context, common.Address) (common.Address, error)) *FEVMQueries_AgentAdministrator_Call {
	_c.Call.Return(run)
	return _c
}

// AgentDefaulted provides a mock function with given fields: ctx, agentAddr
func (_m *FEVMQueries) AgentDefaulted(ctx context.Context, agentAddr common.Address) (bool, error) {
	ret := _m.Called(ctx, agentAddr)

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) (bool, error)); ok {
		return rf(ctx, agentAddr)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) bool); ok {
		r0 = rf(ctx, agentAddr)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Address) error); ok {
		r1 = rf(ctx, agentAddr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_AgentDefaulted_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentDefaulted'
type FEVMQueries_AgentDefaulted_Call struct {
	*mock.Call
}

// AgentDefaulted is a helper method to define mock.On call
//   - ctx context.Context
//   - agentAddr common.Address
func (_e *FEVMQueries_Expecter) AgentDefaulted(ctx interface{}, agentAddr interface{}) *FEVMQueries_AgentDefaulted_Call {
	return &FEVMQueries_AgentDefaulted_Call{Call: _e.mock.On("AgentDefaulted", ctx, agentAddr)}
}

func (_c *FEVMQueries_AgentDefaulted_Call) Run(run func(ctx context.Context, agentAddr common.Address)) *FEVMQueries_AgentDefaulted_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Address))
	})
	return _c
}

func (_c *FEVMQueries_AgentDefaulted_Call) Return(_a0 bool, _a1 error) *FEVMQueries_AgentDefaulted_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_AgentDefaulted_Call) RunAndReturn(run func(context.Context, common.Address) (bool, error)) *FEVMQueries_AgentDefaulted_Call {
	_c.Call.Return(run)
	return _c
}

// AgentFactory provides a mock function with given fields:
func (_m *FEVMQueries) AgentFactory() common.Address {
	ret := _m.Called()

	var r0 common.Address
	if rf, ok := ret.Get(0).(func() common.Address); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	return r0
}

// FEVMQueries_AgentFactory_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentFactory'
type FEVMQueries_AgentFactory_Call struct {
	*mock.Call
}

// AgentFactory is a helper method to define mock.On call
func (_e *FEVMQueries_Expecter) AgentFactory() *FEVMQueries_AgentFactory_Call {
	return &FEVMQueries_AgentFactory_Call{Call: _e.mock.On("AgentFactory")}
}

func (_c *FEVMQueries_AgentFactory_Call) Run(run func()) *FEVMQueries_AgentFactory_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *FEVMQueries_AgentFactory_Call) Return(_a0 common.Address) *FEVMQueries_AgentFactory_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *FEVMQueries_AgentFactory_Call) RunAndReturn(run func() common.Address) *FEVMQueries_AgentFactory_Call {
	_c.Call.Return(run)
	return _c
}

// AgentFactoryAgentCount provides a mock function with given fields: ctx
func (_m *FEVMQueries) AgentFactoryAgentCount(ctx context.Context) (*big.Int, error) {
	ret := _m.Called(ctx)

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*big.Int, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *big.Int); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_AgentFactoryAgentCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentFactoryAgentCount'
type FEVMQueries_AgentFactoryAgentCount_Call struct {
	*mock.Call
}

// AgentFactoryAgentCount is a helper method to define mock.On call
//   - ctx context.Context
func (_e *FEVMQueries_Expecter) AgentFactoryAgentCount(ctx interface{}) *FEVMQueries_AgentFactoryAgentCount_Call {
	return &FEVMQueries_AgentFactoryAgentCount_Call{Call: _e.mock.On("AgentFactoryAgentCount", ctx)}
}

func (_c *FEVMQueries_AgentFactoryAgentCount_Call) Run(run func(ctx context.Context)) *FEVMQueries_AgentFactoryAgentCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FEVMQueries_AgentFactoryAgentCount_Call) Return(_a0 *big.Int, _a1 error) *FEVMQueries_AgentFactoryAgentCount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_AgentFactoryAgentCount_Call) RunAndReturn(run func(context.Context) (*big.Int, error)) *FEVMQueries_AgentFactoryAgentCount_Call {
	_c.Call.Return(run)
	return _c
}

// AgentFaultyEpochStart provides a mock function with given fields: ctx, agentAddr
func (_m *FEVMQueries) AgentFaultyEpochStart(ctx context.Context, agentAddr common.Address) (*big.Int, error) {
	ret := _m.Called(ctx, agentAddr)

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) (*big.Int, error)); ok {
		return rf(ctx, agentAddr)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) *big.Int); ok {
		r0 = rf(ctx, agentAddr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Address) error); ok {
		r1 = rf(ctx, agentAddr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_AgentFaultyEpochStart_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentFaultyEpochStart'
type FEVMQueries_AgentFaultyEpochStart_Call struct {
	*mock.Call
}

// AgentFaultyEpochStart is a helper method to define mock.On call
//   - ctx context.Context
//   - agentAddr common.Address
func (_e *FEVMQueries_Expecter) AgentFaultyEpochStart(ctx interface{}, agentAddr interface{}) *FEVMQueries_AgentFaultyEpochStart_Call {
	return &FEVMQueries_AgentFaultyEpochStart_Call{Call: _e.mock.On("AgentFaultyEpochStart", ctx, agentAddr)}
}

func (_c *FEVMQueries_AgentFaultyEpochStart_Call) Run(run func(ctx context.Context, agentAddr common.Address)) *FEVMQueries_AgentFaultyEpochStart_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Address))
	})
	return _c
}

func (_c *FEVMQueries_AgentFaultyEpochStart_Call) Return(_a0 *big.Int, _a1 error) *FEVMQueries_AgentFaultyEpochStart_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_AgentFaultyEpochStart_Call) RunAndReturn(run func(context.Context, common.Address) (*big.Int, error)) *FEVMQueries_AgentFaultyEpochStart_Call {
	_c.Call.Return(run)
	return _c
}

// AgentID provides a mock function with given fields: ctx, agentAddr
func (_m *FEVMQueries) AgentID(ctx context.Context, agentAddr common.Address) (*big.Int, error) {
	ret := _m.Called(ctx, agentAddr)

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) (*big.Int, error)); ok {
		return rf(ctx, agentAddr)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) *big.Int); ok {
		r0 = rf(ctx, agentAddr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Address) error); ok {
		r1 = rf(ctx, agentAddr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_AgentID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentID'
type FEVMQueries_AgentID_Call struct {
	*mock.Call
}

// AgentID is a helper method to define mock.On call
//   - ctx context.Context
//   - agentAddr common.Address
func (_e *FEVMQueries_Expecter) AgentID(ctx interface{}, agentAddr interface{}) *FEVMQueries_AgentID_Call {
	return &FEVMQueries_AgentID_Call{Call: _e.mock.On("AgentID", ctx, agentAddr)}
}

func (_c *FEVMQueries_AgentID_Call) Run(run func(ctx context.Context, agentAddr common.Address)) *FEVMQueries_AgentID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Address))
	})
	return _c
}

func (_c *FEVMQueries_AgentID_Call) Return(_a0 *big.Int, _a1 error) *FEVMQueries_AgentID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_AgentID_Call) RunAndReturn(run func(context.Context, common.Address) (*big.Int, error)) *FEVMQueries_AgentID_Call {
	_c.Call.Return(run)
	return _c
}

// AgentIsValid provides a mock function with given fields: ctx, agentAddr
func (_m *FEVMQueries) AgentIsValid(ctx context.Context, agentAddr common.Address) (bool, error) {
	ret := _m.Called(ctx, agentAddr)

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) (bool, error)); ok {
		return rf(ctx, agentAddr)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) bool); ok {
		r0 = rf(ctx, agentAddr)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Address) error); ok {
		r1 = rf(ctx, agentAddr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_AgentIsValid_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentIsValid'
type FEVMQueries_AgentIsValid_Call struct {
	*mock.Call
}

// AgentIsValid is a helper method to define mock.On call
//   - ctx context.Context
//   - agentAddr common.Address
func (_e *FEVMQueries_Expecter) AgentIsValid(ctx interface{}, agentAddr interface{}) *FEVMQueries_AgentIsValid_Call {
	return &FEVMQueries_AgentIsValid_Call{Call: _e.mock.On("AgentIsValid", ctx, agentAddr)}
}

func (_c *FEVMQueries_AgentIsValid_Call) Run(run func(ctx context.Context, agentAddr common.Address)) *FEVMQueries_AgentIsValid_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Address))
	})
	return _c
}

func (_c *FEVMQueries_AgentIsValid_Call) Return(_a0 bool, _a1 error) *FEVMQueries_AgentIsValid_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_AgentIsValid_Call) RunAndReturn(run func(context.Context, common.Address) (bool, error)) *FEVMQueries_AgentIsValid_Call {
	_c.Call.Return(run)
	return _c
}

// AgentLiquidAssets provides a mock function with given fields: ctx, agentAddr
func (_m *FEVMQueries) AgentLiquidAssets(ctx context.Context, agentAddr common.Address) (*big.Int, error) {
	ret := _m.Called(ctx, agentAddr)

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) (*big.Int, error)); ok {
		return rf(ctx, agentAddr)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) *big.Int); ok {
		r0 = rf(ctx, agentAddr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Address) error); ok {
		r1 = rf(ctx, agentAddr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_AgentLiquidAssets_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentLiquidAssets'
type FEVMQueries_AgentLiquidAssets_Call struct {
	*mock.Call
}

// AgentLiquidAssets is a helper method to define mock.On call
//   - ctx context.Context
//   - agentAddr common.Address
func (_e *FEVMQueries_Expecter) AgentLiquidAssets(ctx interface{}, agentAddr interface{}) *FEVMQueries_AgentLiquidAssets_Call {
	return &FEVMQueries_AgentLiquidAssets_Call{Call: _e.mock.On("AgentLiquidAssets", ctx, agentAddr)}
}

func (_c *FEVMQueries_AgentLiquidAssets_Call) Run(run func(ctx context.Context, agentAddr common.Address)) *FEVMQueries_AgentLiquidAssets_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Address))
	})
	return _c
}

func (_c *FEVMQueries_AgentLiquidAssets_Call) Return(_a0 *big.Int, _a1 error) *FEVMQueries_AgentLiquidAssets_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_AgentLiquidAssets_Call) RunAndReturn(run func(context.Context, common.Address) (*big.Int, error)) *FEVMQueries_AgentLiquidAssets_Call {
	_c.Call.Return(run)
	return _c
}

// AgentMiners provides a mock function with given fields: ctx, agentAddr
func (_m *FEVMQueries) AgentMiners(ctx context.Context, agentAddr common.Address) ([]address.Address, error) {
	ret := _m.Called(ctx, agentAddr)

	var r0 []address.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) ([]address.Address, error)); ok {
		return rf(ctx, agentAddr)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) []address.Address); ok {
		r0 = rf(ctx, agentAddr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]address.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Address) error); ok {
		r1 = rf(ctx, agentAddr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_AgentMiners_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentMiners'
type FEVMQueries_AgentMiners_Call struct {
	*mock.Call
}

// AgentMiners is a helper method to define mock.On call
//   - ctx context.Context
//   - agentAddr common.Address
func (_e *FEVMQueries_Expecter) AgentMiners(ctx interface{}, agentAddr interface{}) *FEVMQueries_AgentMiners_Call {
	return &FEVMQueries_AgentMiners_Call{Call: _e.mock.On("AgentMiners", ctx, agentAddr)}
}

func (_c *FEVMQueries_AgentMiners_Call) Run(run func(ctx context.Context, agentAddr common.Address)) *FEVMQueries_AgentMiners_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Address))
	})
	return _c
}

func (_c *FEVMQueries_AgentMiners_Call) Return(_a0 []address.Address, _a1 error) *FEVMQueries_AgentMiners_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_AgentMiners_Call) RunAndReturn(run func(context.Context, common.Address) ([]address.Address, error)) *FEVMQueries_AgentMiners_Call {
	_c.Call.Return(run)
	return _c
}

// AgentOperator provides a mock function with given fields: ctx, agentAddr
func (_m *FEVMQueries) AgentOperator(ctx context.Context, agentAddr common.Address) (common.Address, error) {
	ret := _m.Called(ctx, agentAddr)

	var r0 common.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) (common.Address, error)); ok {
		return rf(ctx, agentAddr)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) common.Address); ok {
		r0 = rf(ctx, agentAddr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Address) error); ok {
		r1 = rf(ctx, agentAddr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_AgentOperator_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentOperator'
type FEVMQueries_AgentOperator_Call struct {
	*mock.Call
}

// AgentOperator is a helper method to define mock.On call
//   - ctx context.Context
//   - agentAddr common.Address
func (_e *FEVMQueries_Expecter) AgentOperator(ctx interface{}, agentAddr interface{}) *FEVMQueries_AgentOperator_Call {
	return &FEVMQueries_AgentOperator_Call{Call: _e.mock.On("AgentOperator", ctx, agentAddr)}
}

func (_c *FEVMQueries_AgentOperator_Call) Run(run func(ctx context.Context, agentAddr common.Address)) *FEVMQueries_AgentOperator_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Address))
	})
	return _c
}

func (_c *FEVMQueries_AgentOperator_Call) Return(_a0 common.Address, _a1 error) *FEVMQueries_AgentOperator_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_AgentOperator_Call) RunAndReturn(run func(context.Context, common.Address) (common.Address, error)) *FEVMQueries_AgentOperator_Call {
	_c.Call.Return(run)
	return _c
}

// AgentOwes provides a mock function with given fields: ctx, agentAddr
func (_m *FEVMQueries) AgentOwes(ctx context.Context, agentAddr common.Address) (*big.Int, *big.Int, error) {
	ret := _m.Called(ctx, agentAddr)

	var r0 *big.Int
	var r1 *big.Int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) (*big.Int, *big.Int, error)); ok {
		return rf(ctx, agentAddr)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) *big.Int); ok {
		r0 = rf(ctx, agentAddr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Address) *big.Int); ok {
		r1 = rf(ctx, agentAddr)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*big.Int)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, common.Address) error); ok {
		r2 = rf(ctx, agentAddr)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// FEVMQueries_AgentOwes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentOwes'
type FEVMQueries_AgentOwes_Call struct {
	*mock.Call
}

// AgentOwes is a helper method to define mock.On call
//   - ctx context.Context
//   - agentAddr common.Address
func (_e *FEVMQueries_Expecter) AgentOwes(ctx interface{}, agentAddr interface{}) *FEVMQueries_AgentOwes_Call {
	return &FEVMQueries_AgentOwes_Call{Call: _e.mock.On("AgentOwes", ctx, agentAddr)}
}

func (_c *FEVMQueries_AgentOwes_Call) Run(run func(ctx context.Context, agentAddr common.Address)) *FEVMQueries_AgentOwes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Address))
	})
	return _c
}

func (_c *FEVMQueries_AgentOwes_Call) Return(_a0 *big.Int, _a1 *big.Int, _a2 error) *FEVMQueries_AgentOwes_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *FEVMQueries_AgentOwes_Call) RunAndReturn(run func(context.Context, common.Address) (*big.Int, *big.Int, error)) *FEVMQueries_AgentOwes_Call {
	_c.Call.Return(run)
	return _c
}

// AgentOwner provides a mock function with given fields: ctx, agentAddr
func (_m *FEVMQueries) AgentOwner(ctx context.Context, agentAddr common.Address) (common.Address, error) {
	ret := _m.Called(ctx, agentAddr)

	var r0 common.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) (common.Address, error)); ok {
		return rf(ctx, agentAddr)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) common.Address); ok {
		r0 = rf(ctx, agentAddr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Address) error); ok {
		r1 = rf(ctx, agentAddr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_AgentOwner_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentOwner'
type FEVMQueries_AgentOwner_Call struct {
	*mock.Call
}

// AgentOwner is a helper method to define mock.On call
//   - ctx context.Context
//   - agentAddr common.Address
func (_e *FEVMQueries_Expecter) AgentOwner(ctx interface{}, agentAddr interface{}) *FEVMQueries_AgentOwner_Call {
	return &FEVMQueries_AgentOwner_Call{Call: _e.mock.On("AgentOwner", ctx, agentAddr)}
}

func (_c *FEVMQueries_AgentOwner_Call) Run(run func(ctx context.Context, agentAddr common.Address)) *FEVMQueries_AgentOwner_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Address))
	})
	return _c
}

func (_c *FEVMQueries_AgentOwner_Call) Return(_a0 common.Address, _a1 error) *FEVMQueries_AgentOwner_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_AgentOwner_Call) RunAndReturn(run func(context.Context, common.Address) (common.Address, error)) *FEVMQueries_AgentOwner_Call {
	_c.Call.Return(run)
	return _c
}

// AgentPolice provides a mock function with given fields:
func (_m *FEVMQueries) AgentPolice() common.Address {
	ret := _m.Called()

	var r0 common.Address
	if rf, ok := ret.Get(0).(func() common.Address); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	return r0
}

// FEVMQueries_AgentPolice_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentPolice'
type FEVMQueries_AgentPolice_Call struct {
	*mock.Call
}

// AgentPolice is a helper method to define mock.On call
func (_e *FEVMQueries_Expecter) AgentPolice() *FEVMQueries_AgentPolice_Call {
	return &FEVMQueries_AgentPolice_Call{Call: _e.mock.On("AgentPolice")}
}

func (_c *FEVMQueries_AgentPolice_Call) Run(run func()) *FEVMQueries_AgentPolice_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *FEVMQueries_AgentPolice_Call) Return(_a0 common.Address) *FEVMQueries_AgentPolice_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *FEVMQueries_AgentPolice_Call) RunAndReturn(run func() common.Address) *FEVMQueries_AgentPolice_Call {
	_c.Call.Return(run)
	return _c
}

// AgentPrincipal provides a mock function with given fields: ctx, agentAddr
func (_m *FEVMQueries) AgentPrincipal(ctx context.Context, agentAddr common.Address) (*big.Int, error) {
	ret := _m.Called(ctx, agentAddr)

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) (*big.Int, error)); ok {
		return rf(ctx, agentAddr)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) *big.Int); ok {
		r0 = rf(ctx, agentAddr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Address) error); ok {
		r1 = rf(ctx, agentAddr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_AgentPrincipal_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentPrincipal'
type FEVMQueries_AgentPrincipal_Call struct {
	*mock.Call
}

// AgentPrincipal is a helper method to define mock.On call
//   - ctx context.Context
//   - agentAddr common.Address
func (_e *FEVMQueries_Expecter) AgentPrincipal(ctx interface{}, agentAddr interface{}) *FEVMQueries_AgentPrincipal_Call {
	return &FEVMQueries_AgentPrincipal_Call{Call: _e.mock.On("AgentPrincipal", ctx, agentAddr)}
}

func (_c *FEVMQueries_AgentPrincipal_Call) Run(run func(ctx context.Context, agentAddr common.Address)) *FEVMQueries_AgentPrincipal_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Address))
	})
	return _c
}

func (_c *FEVMQueries_AgentPrincipal_Call) Return(_a0 *big.Int, _a1 error) *FEVMQueries_AgentPrincipal_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_AgentPrincipal_Call) RunAndReturn(run func(context.Context, common.Address) (*big.Int, error)) *FEVMQueries_AgentPrincipal_Call {
	_c.Call.Return(run)
	return _c
}

// AgentRequester provides a mock function with given fields: ctx, agentAddr
func (_m *FEVMQueries) AgentRequester(ctx context.Context, agentAddr common.Address) (common.Address, error) {
	ret := _m.Called(ctx, agentAddr)

	var r0 common.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) (common.Address, error)); ok {
		return rf(ctx, agentAddr)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) common.Address); ok {
		r0 = rf(ctx, agentAddr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Address) error); ok {
		r1 = rf(ctx, agentAddr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_AgentRequester_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentRequester'
type FEVMQueries_AgentRequester_Call struct {
	*mock.Call
}

// AgentRequester is a helper method to define mock.On call
//   - ctx context.Context
//   - agentAddr common.Address
func (_e *FEVMQueries_Expecter) AgentRequester(ctx interface{}, agentAddr interface{}) *FEVMQueries_AgentRequester_Call {
	return &FEVMQueries_AgentRequester_Call{Call: _e.mock.On("AgentRequester", ctx, agentAddr)}
}

func (_c *FEVMQueries_AgentRequester_Call) Run(run func(ctx context.Context, agentAddr common.Address)) *FEVMQueries_AgentRequester_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Address))
	})
	return _c
}

func (_c *FEVMQueries_AgentRequester_Call) Return(_a0 common.Address, _a1 error) *FEVMQueries_AgentRequester_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_AgentRequester_Call) RunAndReturn(run func(context.Context, common.Address) (common.Address, error)) *FEVMQueries_AgentRequester_Call {
	_c.Call.Return(run)
	return _c
}

// AgentVersion provides a mock function with given fields: ctx, agentAddr
func (_m *FEVMQueries) AgentVersion(ctx context.Context, agentAddr common.Address) (uint8, uint8, error) {
	ret := _m.Called(ctx, agentAddr)

	var r0 uint8
	var r1 uint8
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) (uint8, uint8, error)); ok {
		return rf(ctx, agentAddr)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) uint8); ok {
		r0 = rf(ctx, agentAddr)
	} else {
		r0 = ret.Get(0).(uint8)
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Address) uint8); ok {
		r1 = rf(ctx, agentAddr)
	} else {
		r1 = ret.Get(1).(uint8)
	}

	if rf, ok := ret.Get(2).(func(context.Context, common.Address) error); ok {
		r2 = rf(ctx, agentAddr)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// FEVMQueries_AgentVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentVersion'
type FEVMQueries_AgentVersion_Call struct {
	*mock.Call
}

// AgentVersion is a helper method to define mock.On call
//   - ctx context.Context
//   - agentAddr common.Address
func (_e *FEVMQueries_Expecter) AgentVersion(ctx interface{}, agentAddr interface{}) *FEVMQueries_AgentVersion_Call {
	return &FEVMQueries_AgentVersion_Call{Call: _e.mock.On("AgentVersion", ctx, agentAddr)}
}

func (_c *FEVMQueries_AgentVersion_Call) Run(run func(ctx context.Context, agentAddr common.Address)) *FEVMQueries_AgentVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Address))
	})
	return _c
}

func (_c *FEVMQueries_AgentVersion_Call) Return(_a0 uint8, _a1 uint8, _a2 error) *FEVMQueries_AgentVersion_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *FEVMQueries_AgentVersion_Call) RunAndReturn(run func(context.Context, common.Address) (uint8, uint8, error)) *FEVMQueries_AgentVersion_Call {
	_c.Call.Return(run)
	return _c
}

// ChainGetNonce provides a mock function with given fields: ctx, fromAddr
func (_m *FEVMQueries) ChainGetNonce(ctx context.Context, fromAddr common.Address) (*big.Int, error) {
	ret := _m.Called(ctx, fromAddr)

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) (*big.Int, error)); ok {
		return rf(ctx, fromAddr)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) *big.Int); ok {
		r0 = rf(ctx, fromAddr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Address) error); ok {
		r1 = rf(ctx, fromAddr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_ChainGetNonce_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChainGetNonce'
type FEVMQueries_ChainGetNonce_Call struct {
	*mock.Call
}

// ChainGetNonce is a helper method to define mock.On call
//   - ctx context.Context
//   - fromAddr common.Address
func (_e *FEVMQueries_Expecter) ChainGetNonce(ctx interface{}, fromAddr interface{}) *FEVMQueries_ChainGetNonce_Call {
	return &FEVMQueries_ChainGetNonce_Call{Call: _e.mock.On("ChainGetNonce", ctx, fromAddr)}
}

func (_c *FEVMQueries_ChainGetNonce_Call) Run(run func(ctx context.Context, fromAddr common.Address)) *FEVMQueries_ChainGetNonce_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Address))
	})
	return _c
}

func (_c *FEVMQueries_ChainGetNonce_Call) Return(_a0 *big.Int, _a1 error) *FEVMQueries_ChainGetNonce_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_ChainGetNonce_Call) RunAndReturn(run func(context.Context, common.Address) (*big.Int, error)) *FEVMQueries_ChainGetNonce_Call {
	_c.Call.Return(run)
	return _c
}

// ChainHead provides a mock function with given fields: ctx
func (_m *FEVMQueries) ChainHead(ctx context.Context) (*chaintypes.TipSet, error) {
	ret := _m.Called(ctx)

	var r0 *chaintypes.TipSet
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*chaintypes.TipSet, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *chaintypes.TipSet); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*chaintypes.TipSet)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_ChainHead_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChainHead'
type FEVMQueries_ChainHead_Call struct {
	*mock.Call
}

// ChainHead is a helper method to define mock.On call
//   - ctx context.Context
func (_e *FEVMQueries_Expecter) ChainHead(ctx interface{}) *FEVMQueries_ChainHead_Call {
	return &FEVMQueries_ChainHead_Call{Call: _e.mock.On("ChainHead", ctx)}
}

func (_c *FEVMQueries_ChainHead_Call) Run(run func(ctx context.Context)) *FEVMQueries_ChainHead_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FEVMQueries_ChainHead_Call) Return(_a0 *chaintypes.TipSet, _a1 error) *FEVMQueries_ChainHead_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_ChainHead_Call) RunAndReturn(run func(context.Context) (*chaintypes.TipSet, error)) *FEVMQueries_ChainHead_Call {
	_c.Call.Return(run)
	return _c
}

// ChainHeight provides a mock function with given fields: ctx
func (_m *FEVMQueries) ChainHeight(ctx context.Context) (*big.Int, error) {
	ret := _m.Called(ctx)

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*big.Int, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *big.Int); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_ChainHeight_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChainHeight'
type FEVMQueries_ChainHeight_Call struct {
	*mock.Call
}

// ChainHeight is a helper method to define mock.On call
//   - ctx context.Context
func (_e *FEVMQueries_Expecter) ChainHeight(ctx interface{}) *FEVMQueries_ChainHeight_Call {
	return &FEVMQueries_ChainHeight_Call{Call: _e.mock.On("ChainHeight", ctx)}
}

func (_c *FEVMQueries_ChainHeight_Call) Run(run func(ctx context.Context)) *FEVMQueries_ChainHeight_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FEVMQueries_ChainHeight_Call) Return(_a0 *big.Int, _a1 error) *FEVMQueries_ChainHeight_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_ChainHeight_Call) RunAndReturn(run func(context.Context) (*big.Int, error)) *FEVMQueries_ChainHeight_Call {
	_c.Call.Return(run)
	return _c
}

// ChainID provides a mock function with given fields:
func (_m *FEVMQueries) ChainID() *big.Int {
	ret := _m.Called()

	var r0 *big.Int
	if rf, ok := ret.Get(0).(func() *big.Int); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	return r0
}

// FEVMQueries_ChainID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChainID'
type FEVMQueries_ChainID_Call struct {
	*mock.Call
}

// ChainID is a helper method to define mock.On call
func (_e *FEVMQueries_Expecter) ChainID() *FEVMQueries_ChainID_Call {
	return &FEVMQueries_ChainID_Call{Call: _e.mock.On("ChainID")}
}

func (_c *FEVMQueries_ChainID_Call) Run(run func()) *FEVMQueries_ChainID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *FEVMQueries_ChainID_Call) Return(_a0 *big.Int) *FEVMQueries_ChainID_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *FEVMQueries_ChainID_Call) RunAndReturn(run func() *big.Int) *FEVMQueries_ChainID_Call {
	_c.Call.Return(run)
	return _c
}

// CredentialUsed provides a mock function with given fields: ctx, v, r, s
func (_m *FEVMQueries) CredentialUsed(ctx context.Context, v uint8, r [32]byte, s [32]byte) (bool, error) {
	ret := _m.Called(ctx, v, r, s)

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint8, [32]byte, [32]byte) (bool, error)); ok {
		return rf(ctx, v, r, s)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint8, [32]byte, [32]byte) bool); ok {
		r0 = rf(ctx, v, r, s)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint8, [32]byte, [32]byte) error); ok {
		r1 = rf(ctx, v, r, s)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_CredentialUsed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CredentialUsed'
type FEVMQueries_CredentialUsed_Call struct {
	*mock.Call
}

// CredentialUsed is a helper method to define mock.On call
//   - ctx context.Context
//   - v uint8
//   - r [32]byte
//   - s [32]byte
func (_e *FEVMQueries_Expecter) CredentialUsed(ctx interface{}, v interface{}, r interface{}, s interface{}) *FEVMQueries_CredentialUsed_Call {
	return &FEVMQueries_CredentialUsed_Call{Call: _e.mock.On("CredentialUsed", ctx, v, r, s)}
}

func (_c *FEVMQueries_CredentialUsed_Call) Run(run func(ctx context.Context, v uint8, r [32]byte, s [32]byte)) *FEVMQueries_CredentialUsed_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint8), args[2].([32]byte), args[3].([32]byte))
	})
	return _c
}

func (_c *FEVMQueries_CredentialUsed_Call) Return(_a0 bool, _a1 error) *FEVMQueries_CredentialUsed_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_CredentialUsed_Call) RunAndReturn(run func(context.Context, uint8, [32]byte, [32]byte) (bool, error)) *FEVMQueries_CredentialUsed_Call {
	_c.Call.Return(run)
	return _c
}

// CredentialValidityPeriod provides a mock function with given fields: ctx
func (_m *FEVMQueries) CredentialValidityPeriod(ctx context.Context) (*big.Int, *big.Int, error) {
	ret := _m.Called(ctx)

	var r0 *big.Int
	var r1 *big.Int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context) (*big.Int, *big.Int, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *big.Int); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) *big.Int); ok {
		r1 = rf(ctx)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*big.Int)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context) error); ok {
		r2 = rf(ctx)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// FEVMQueries_CredentialValidityPeriod_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CredentialValidityPeriod'
type FEVMQueries_CredentialValidityPeriod_Call struct {
	*mock.Call
}

// CredentialValidityPeriod is a helper method to define mock.On call
//   - ctx context.Context
func (_e *FEVMQueries_Expecter) CredentialValidityPeriod(ctx interface{}) *FEVMQueries_CredentialValidityPeriod_Call {
	return &FEVMQueries_CredentialValidityPeriod_Call{Call: _e.mock.On("CredentialValidityPeriod", ctx)}
}

func (_c *FEVMQueries_CredentialValidityPeriod_Call) Run(run func(ctx context.Context)) *FEVMQueries_CredentialValidityPeriod_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FEVMQueries_CredentialValidityPeriod_Call) Return(_a0 *big.Int, _a1 *big.Int, _a2 error) *FEVMQueries_CredentialValidityPeriod_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *FEVMQueries_CredentialValidityPeriod_Call) RunAndReturn(run func(context.Context) (*big.Int, *big.Int, error)) *FEVMQueries_CredentialValidityPeriod_Call {
	_c.Call.Return(run)
	return _c
}

// DefaultEpoch provides a mock function with given fields: ctx
func (_m *FEVMQueries) DefaultEpoch(ctx context.Context) (*big.Int, error) {
	ret := _m.Called(ctx)

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*big.Int, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *big.Int); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_DefaultEpoch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DefaultEpoch'
type FEVMQueries_DefaultEpoch_Call struct {
	*mock.Call
}

// DefaultEpoch is a helper method to define mock.On call
//   - ctx context.Context
func (_e *FEVMQueries_Expecter) DefaultEpoch(ctx interface{}) *FEVMQueries_DefaultEpoch_Call {
	return &FEVMQueries_DefaultEpoch_Call{Call: _e.mock.On("DefaultEpoch", ctx)}
}

func (_c *FEVMQueries_DefaultEpoch_Call) Run(run func(ctx context.Context)) *FEVMQueries_DefaultEpoch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FEVMQueries_DefaultEpoch_Call) Return(_a0 *big.Int, _a1 error) *FEVMQueries_DefaultEpoch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_DefaultEpoch_Call) RunAndReturn(run func(context.Context) (*big.Int, error)) *FEVMQueries_DefaultEpoch_Call {
	_c.Call.Return(run)
	return _c
}

// IFIL provides a mock function with given fields:
func (_m *FEVMQueries) IFIL() common.Address {
	ret := _m.Called()

	var r0 common.Address
	if rf, ok := ret.Get(0).(func() common.Address); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	return r0
}

// FEVMQueries_IFIL_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IFIL'
type FEVMQueries_IFIL_Call struct {
	*mock.Call
}

// IFIL is a helper method to define mock.On call
func (_e *FEVMQueries_Expecter) IFIL() *FEVMQueries_IFIL_Call {
	return &FEVMQueries_IFIL_Call{Call: _e.mock.On("IFIL")}
}

func (_c *FEVMQueries_IFIL_Call) Run(run func()) *FEVMQueries_IFIL_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *FEVMQueries_IFIL_Call) Return(_a0 common.Address) *FEVMQueries_IFIL_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *FEVMQueries_IFIL_Call) RunAndReturn(run func() common.Address) *FEVMQueries_IFIL_Call {
	_c.Call.Return(run)
	return _c
}

// IFILBalanceOf provides a mock function with given fields: ctx, hodler
func (_m *FEVMQueries) IFILBalanceOf(ctx context.Context, hodler common.Address) (*big.Float, error) {
	ret := _m.Called(ctx, hodler)

	var r0 *big.Float
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) (*big.Float, error)); ok {
		return rf(ctx, hodler)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) *big.Float); ok {
		r0 = rf(ctx, hodler)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Float)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Address) error); ok {
		r1 = rf(ctx, hodler)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_IFILBalanceOf_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IFILBalanceOf'
type FEVMQueries_IFILBalanceOf_Call struct {
	*mock.Call
}

// IFILBalanceOf is a helper method to define mock.On call
//   - ctx context.Context
//   - hodler common.Address
func (_e *FEVMQueries_Expecter) IFILBalanceOf(ctx interface{}, hodler interface{}) *FEVMQueries_IFILBalanceOf_Call {
	return &FEVMQueries_IFILBalanceOf_Call{Call: _e.mock.On("IFILBalanceOf", ctx, hodler)}
}

func (_c *FEVMQueries_IFILBalanceOf_Call) Run(run func(ctx context.Context, hodler common.Address)) *FEVMQueries_IFILBalanceOf_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Address))
	})
	return _c
}

func (_c *FEVMQueries_IFILBalanceOf_Call) Return(_a0 *big.Float, _a1 error) *FEVMQueries_IFILBalanceOf_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_IFILBalanceOf_Call) RunAndReturn(run func(context.Context, common.Address) (*big.Float, error)) *FEVMQueries_IFILBalanceOf_Call {
	_c.Call.Return(run)
	return _c
}

// IFILBurner provides a mock function with given fields: ctx
func (_m *FEVMQueries) IFILBurner(ctx context.Context) (common.Address, error) {
	ret := _m.Called(ctx)

	var r0 common.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (common.Address, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) common.Address); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_IFILBurner_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IFILBurner'
type FEVMQueries_IFILBurner_Call struct {
	*mock.Call
}

// IFILBurner is a helper method to define mock.On call
//   - ctx context.Context
func (_e *FEVMQueries_Expecter) IFILBurner(ctx interface{}) *FEVMQueries_IFILBurner_Call {
	return &FEVMQueries_IFILBurner_Call{Call: _e.mock.On("IFILBurner", ctx)}
}

func (_c *FEVMQueries_IFILBurner_Call) Run(run func(ctx context.Context)) *FEVMQueries_IFILBurner_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FEVMQueries_IFILBurner_Call) Return(_a0 common.Address, _a1 error) *FEVMQueries_IFILBurner_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_IFILBurner_Call) RunAndReturn(run func(context.Context) (common.Address, error)) *FEVMQueries_IFILBurner_Call {
	_c.Call.Return(run)
	return _c
}

// IFILMinter provides a mock function with given fields: ctx
func (_m *FEVMQueries) IFILMinter(ctx context.Context) (common.Address, error) {
	ret := _m.Called(ctx)

	var r0 common.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (common.Address, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) common.Address); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_IFILMinter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IFILMinter'
type FEVMQueries_IFILMinter_Call struct {
	*mock.Call
}

// IFILMinter is a helper method to define mock.On call
//   - ctx context.Context
func (_e *FEVMQueries_Expecter) IFILMinter(ctx interface{}) *FEVMQueries_IFILMinter_Call {
	return &FEVMQueries_IFILMinter_Call{Call: _e.mock.On("IFILMinter", ctx)}
}

func (_c *FEVMQueries_IFILMinter_Call) Run(run func(ctx context.Context)) *FEVMQueries_IFILMinter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FEVMQueries_IFILMinter_Call) Return(_a0 common.Address, _a1 error) *FEVMQueries_IFILMinter_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_IFILMinter_Call) RunAndReturn(run func(context.Context) (common.Address, error)) *FEVMQueries_IFILMinter_Call {
	_c.Call.Return(run)
	return _c
}

// IFILPrice provides a mock function with given fields: ctx
func (_m *FEVMQueries) IFILPrice(ctx context.Context) (*big.Float, error) {
	ret := _m.Called(ctx)

	var r0 *big.Float
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*big.Float, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *big.Float); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Float)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_IFILPrice_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IFILPrice'
type FEVMQueries_IFILPrice_Call struct {
	*mock.Call
}

// IFILPrice is a helper method to define mock.On call
//   - ctx context.Context
func (_e *FEVMQueries_Expecter) IFILPrice(ctx interface{}) *FEVMQueries_IFILPrice_Call {
	return &FEVMQueries_IFILPrice_Call{Call: _e.mock.On("IFILPrice", ctx)}
}

func (_c *FEVMQueries_IFILPrice_Call) Run(run func(ctx context.Context)) *FEVMQueries_IFILPrice_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FEVMQueries_IFILPrice_Call) Return(_a0 *big.Float, _a1 error) *FEVMQueries_IFILPrice_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_IFILPrice_Call) RunAndReturn(run func(context.Context) (*big.Float, error)) *FEVMQueries_IFILPrice_Call {
	_c.Call.Return(run)
	return _c
}

// InfPoolBorrowableLiquidity provides a mock function with given fields: ctx
func (_m *FEVMQueries) InfPoolBorrowableLiquidity(ctx context.Context) (*big.Float, error) {
	ret := _m.Called(ctx)

	var r0 *big.Float
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*big.Float, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *big.Float); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Float)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_InfPoolBorrowableLiquidity_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InfPoolBorrowableLiquidity'
type FEVMQueries_InfPoolBorrowableLiquidity_Call struct {
	*mock.Call
}

// InfPoolBorrowableLiquidity is a helper method to define mock.On call
//   - ctx context.Context
func (_e *FEVMQueries_Expecter) InfPoolBorrowableLiquidity(ctx interface{}) *FEVMQueries_InfPoolBorrowableLiquidity_Call {
	return &FEVMQueries_InfPoolBorrowableLiquidity_Call{Call: _e.mock.On("InfPoolBorrowableLiquidity", ctx)}
}

func (_c *FEVMQueries_InfPoolBorrowableLiquidity_Call) Run(run func(ctx context.Context)) *FEVMQueries_InfPoolBorrowableLiquidity_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FEVMQueries_InfPoolBorrowableLiquidity_Call) Return(_a0 *big.Float, _a1 error) *FEVMQueries_InfPoolBorrowableLiquidity_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_InfPoolBorrowableLiquidity_Call) RunAndReturn(run func(context.Context) (*big.Float, error)) *FEVMQueries_InfPoolBorrowableLiquidity_Call {
	_c.Call.Return(run)
	return _c
}

// InfPoolGetAccount provides a mock function with given fields: ctx, agentAddr
func (_m *FEVMQueries) InfPoolGetAccount(ctx context.Context, agentAddr common.Address) (abigen.Account, error) {
	ret := _m.Called(ctx, agentAddr)

	var r0 abigen.Account
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) (abigen.Account, error)); ok {
		return rf(ctx, agentAddr)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) abigen.Account); ok {
		r0 = rf(ctx, agentAddr)
	} else {
		r0 = ret.Get(0).(abigen.Account)
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Address) error); ok {
		r1 = rf(ctx, agentAddr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_InfPoolGetAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InfPoolGetAccount'
type FEVMQueries_InfPoolGetAccount_Call struct {
	*mock.Call
}

// InfPoolGetAccount is a helper method to define mock.On call
//   - ctx context.Context
//   - agentAddr common.Address
func (_e *FEVMQueries_Expecter) InfPoolGetAccount(ctx interface{}, agentAddr interface{}) *FEVMQueries_InfPoolGetAccount_Call {
	return &FEVMQueries_InfPoolGetAccount_Call{Call: _e.mock.On("InfPoolGetAccount", ctx, agentAddr)}
}

func (_c *FEVMQueries_InfPoolGetAccount_Call) Run(run func(ctx context.Context, agentAddr common.Address)) *FEVMQueries_InfPoolGetAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Address))
	})
	return _c
}

func (_c *FEVMQueries_InfPoolGetAccount_Call) Return(_a0 abigen.Account, _a1 error) *FEVMQueries_InfPoolGetAccount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_InfPoolGetAccount_Call) RunAndReturn(run func(context.Context, common.Address) (abigen.Account, error)) *FEVMQueries_InfPoolGetAccount_Call {
	_c.Call.Return(run)
	return _c
}

// InfPoolGetAgentLvl provides a mock function with given fields: ctx, agentID
func (_m *FEVMQueries) InfPoolGetAgentLvl(ctx context.Context, agentID *big.Int) (*big.Int, float64, error) {
	ret := _m.Called(ctx, agentID)

	var r0 *big.Int
	var r1 float64
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, *big.Int) (*big.Int, float64, error)); ok {
		return rf(ctx, agentID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *big.Int) *big.Int); ok {
		r0 = rf(ctx, agentID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *big.Int) float64); ok {
		r1 = rf(ctx, agentID)
	} else {
		r1 = ret.Get(1).(float64)
	}

	if rf, ok := ret.Get(2).(func(context.Context, *big.Int) error); ok {
		r2 = rf(ctx, agentID)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// FEVMQueries_InfPoolGetAgentLvl_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InfPoolGetAgentLvl'
type FEVMQueries_InfPoolGetAgentLvl_Call struct {
	*mock.Call
}

// InfPoolGetAgentLvl is a helper method to define mock.On call
//   - ctx context.Context
//   - agentID *big.Int
func (_e *FEVMQueries_Expecter) InfPoolGetAgentLvl(ctx interface{}, agentID interface{}) *FEVMQueries_InfPoolGetAgentLvl_Call {
	return &FEVMQueries_InfPoolGetAgentLvl_Call{Call: _e.mock.On("InfPoolGetAgentLvl", ctx, agentID)}
}

func (_c *FEVMQueries_InfPoolGetAgentLvl_Call) Run(run func(ctx context.Context, agentID *big.Int)) *FEVMQueries_InfPoolGetAgentLvl_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*big.Int))
	})
	return _c
}

func (_c *FEVMQueries_InfPoolGetAgentLvl_Call) Return(_a0 *big.Int, _a1 float64, _a2 error) *FEVMQueries_InfPoolGetAgentLvl_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *FEVMQueries_InfPoolGetAgentLvl_Call) RunAndReturn(run func(context.Context, *big.Int) (*big.Int, float64, error)) *FEVMQueries_InfPoolGetAgentLvl_Call {
	_c.Call.Return(run)
	return _c
}

// InfPoolGetRate provides a mock function with given fields: ctx, cred
func (_m *FEVMQueries) InfPoolGetRate(ctx context.Context, cred abigen.VerifiableCredential) (*big.Int, error) {
	ret := _m.Called(ctx, cred)

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, abigen.VerifiableCredential) (*big.Int, error)); ok {
		return rf(ctx, cred)
	}
	if rf, ok := ret.Get(0).(func(context.Context, abigen.VerifiableCredential) *big.Int); ok {
		r0 = rf(ctx, cred)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, abigen.VerifiableCredential) error); ok {
		r1 = rf(ctx, cred)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_InfPoolGetRate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InfPoolGetRate'
type FEVMQueries_InfPoolGetRate_Call struct {
	*mock.Call
}

// InfPoolGetRate is a helper method to define mock.On call
//   - ctx context.Context
//   - cred abigen.VerifiableCredential
func (_e *FEVMQueries_Expecter) InfPoolGetRate(ctx interface{}, cred interface{}) *FEVMQueries_InfPoolGetRate_Call {
	return &FEVMQueries_InfPoolGetRate_Call{Call: _e.mock.On("InfPoolGetRate", ctx, cred)}
}

func (_c *FEVMQueries_InfPoolGetRate_Call) Run(run func(ctx context.Context, cred abigen.VerifiableCredential)) *FEVMQueries_InfPoolGetRate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(abigen.VerifiableCredential))
	})
	return _c
}

func (_c *FEVMQueries_InfPoolGetRate_Call) Return(_a0 *big.Int, _a1 error) *FEVMQueries_InfPoolGetRate_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_InfPoolGetRate_Call) RunAndReturn(run func(context.Context, abigen.VerifiableCredential) (*big.Int, error)) *FEVMQueries_InfPoolGetRate_Call {
	_c.Call.Return(run)
	return _c
}

// InfPoolMaxEpochsOwedTolerance provides a mock function with given fields: ctx, agentAddr
func (_m *FEVMQueries) InfPoolMaxEpochsOwedTolerance(ctx context.Context, agentAddr common.Address) (*big.Int, error) {
	ret := _m.Called(ctx, agentAddr)

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) (*big.Int, error)); ok {
		return rf(ctx, agentAddr)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) *big.Int); ok {
		r0 = rf(ctx, agentAddr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Address) error); ok {
		r1 = rf(ctx, agentAddr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_InfPoolMaxEpochsOwedTolerance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InfPoolMaxEpochsOwedTolerance'
type FEVMQueries_InfPoolMaxEpochsOwedTolerance_Call struct {
	*mock.Call
}

// InfPoolMaxEpochsOwedTolerance is a helper method to define mock.On call
//   - ctx context.Context
//   - agentAddr common.Address
func (_e *FEVMQueries_Expecter) InfPoolMaxEpochsOwedTolerance(ctx interface{}, agentAddr interface{}) *FEVMQueries_InfPoolMaxEpochsOwedTolerance_Call {
	return &FEVMQueries_InfPoolMaxEpochsOwedTolerance_Call{Call: _e.mock.On("InfPoolMaxEpochsOwedTolerance", ctx, agentAddr)}
}

func (_c *FEVMQueries_InfPoolMaxEpochsOwedTolerance_Call) Run(run func(ctx context.Context, agentAddr common.Address)) *FEVMQueries_InfPoolMaxEpochsOwedTolerance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Address))
	})
	return _c
}

func (_c *FEVMQueries_InfPoolMaxEpochsOwedTolerance_Call) Return(_a0 *big.Int, _a1 error) *FEVMQueries_InfPoolMaxEpochsOwedTolerance_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_InfPoolMaxEpochsOwedTolerance_Call) RunAndReturn(run func(context.Context, common.Address) (*big.Int, error)) *FEVMQueries_InfPoolMaxEpochsOwedTolerance_Call {
	_c.Call.Return(run)
	return _c
}

// InfPoolRateFromGCRED provides a mock function with given fields: ctx, gcred
func (_m *FEVMQueries) InfPoolRateFromGCRED(ctx context.Context, gcred *big.Int) (*big.Float, error) {
	ret := _m.Called(ctx, gcred)

	var r0 *big.Float
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *big.Int) (*big.Float, error)); ok {
		return rf(ctx, gcred)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *big.Int) *big.Float); ok {
		r0 = rf(ctx, gcred)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Float)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *big.Int) error); ok {
		r1 = rf(ctx, gcred)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_InfPoolRateFromGCRED_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InfPoolRateFromGCRED'
type FEVMQueries_InfPoolRateFromGCRED_Call struct {
	*mock.Call
}

// InfPoolRateFromGCRED is a helper method to define mock.On call
//   - ctx context.Context
//   - gcred *big.Int
func (_e *FEVMQueries_Expecter) InfPoolRateFromGCRED(ctx interface{}, gcred interface{}) *FEVMQueries_InfPoolRateFromGCRED_Call {
	return &FEVMQueries_InfPoolRateFromGCRED_Call{Call: _e.mock.On("InfPoolRateFromGCRED", ctx, gcred)}
}

func (_c *FEVMQueries_InfPoolRateFromGCRED_Call) Run(run func(ctx context.Context, gcred *big.Int)) *FEVMQueries_InfPoolRateFromGCRED_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*big.Int))
	})
	return _c
}

func (_c *FEVMQueries_InfPoolRateFromGCRED_Call) Return(_a0 *big.Float, _a1 error) *FEVMQueries_InfPoolRateFromGCRED_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_InfPoolRateFromGCRED_Call) RunAndReturn(run func(context.Context, *big.Int) (*big.Float, error)) *FEVMQueries_InfPoolRateFromGCRED_Call {
	_c.Call.Return(run)
	return _c
}

// InfPoolTotalAssets provides a mock function with given fields: ctx
func (_m *FEVMQueries) InfPoolTotalAssets(ctx context.Context) (*big.Float, error) {
	ret := _m.Called(ctx)

	var r0 *big.Float
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*big.Float, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *big.Float); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Float)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_InfPoolTotalAssets_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InfPoolTotalAssets'
type FEVMQueries_InfPoolTotalAssets_Call struct {
	*mock.Call
}

// InfPoolTotalAssets is a helper method to define mock.On call
//   - ctx context.Context
func (_e *FEVMQueries_Expecter) InfPoolTotalAssets(ctx interface{}) *FEVMQueries_InfPoolTotalAssets_Call {
	return &FEVMQueries_InfPoolTotalAssets_Call{Call: _e.mock.On("InfPoolTotalAssets", ctx)}
}

func (_c *FEVMQueries_InfPoolTotalAssets_Call) Run(run func(ctx context.Context)) *FEVMQueries_InfPoolTotalAssets_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FEVMQueries_InfPoolTotalAssets_Call) Return(_a0 *big.Float, _a1 error) *FEVMQueries_InfPoolTotalAssets_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_InfPoolTotalAssets_Call) RunAndReturn(run func(context.Context) (*big.Float, error)) *FEVMQueries_InfPoolTotalAssets_Call {
	_c.Call.Return(run)
	return _c
}

// InfPoolTotalBorrowed provides a mock function with given fields: ctx
func (_m *FEVMQueries) InfPoolTotalBorrowed(ctx context.Context) (*big.Float, error) {
	ret := _m.Called(ctx)

	var r0 *big.Float
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*big.Float, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *big.Float); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Float)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_InfPoolTotalBorrowed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InfPoolTotalBorrowed'
type FEVMQueries_InfPoolTotalBorrowed_Call struct {
	*mock.Call
}

// InfPoolTotalBorrowed is a helper method to define mock.On call
//   - ctx context.Context
func (_e *FEVMQueries_Expecter) InfPoolTotalBorrowed(ctx interface{}) *FEVMQueries_InfPoolTotalBorrowed_Call {
	return &FEVMQueries_InfPoolTotalBorrowed_Call{Call: _e.mock.On("InfPoolTotalBorrowed", ctx)}
}

func (_c *FEVMQueries_InfPoolTotalBorrowed_Call) Run(run func(ctx context.Context)) *FEVMQueries_InfPoolTotalBorrowed_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FEVMQueries_InfPoolTotalBorrowed_Call) Return(_a0 *big.Float, _a1 error) *FEVMQueries_InfPoolTotalBorrowed_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_InfPoolTotalBorrowed_Call) RunAndReturn(run func(context.Context) (*big.Float, error)) *FEVMQueries_InfPoolTotalBorrowed_Call {
	_c.Call.Return(run)
	return _c
}

// InfinityPool provides a mock function with given fields:
func (_m *FEVMQueries) InfinityPool() common.Address {
	ret := _m.Called()

	var r0 common.Address
	if rf, ok := ret.Get(0).(func() common.Address); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	return r0
}

// FEVMQueries_InfinityPool_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InfinityPool'
type FEVMQueries_InfinityPool_Call struct {
	*mock.Call
}

// InfinityPool is a helper method to define mock.On call
func (_e *FEVMQueries_Expecter) InfinityPool() *FEVMQueries_InfinityPool_Call {
	return &FEVMQueries_InfinityPool_Call{Call: _e.mock.On("InfinityPool")}
}

func (_c *FEVMQueries_InfinityPool_Call) Run(run func()) *FEVMQueries_InfinityPool_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *FEVMQueries_InfinityPool_Call) Return(_a0 common.Address) *FEVMQueries_InfinityPool_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *FEVMQueries_InfinityPool_Call) RunAndReturn(run func() common.Address) *FEVMQueries_InfinityPool_Call {
	_c.Call.Return(run)
	return _c
}

// ListPools provides a mock function with given fields: ctx
func (_m *FEVMQueries) ListPools(ctx context.Context) ([]common.Address, error) {
	ret := _m.Called(ctx)

	var r0 []common.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]common.Address, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []common.Address); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]common.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_ListPools_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListPools'
type FEVMQueries_ListPools_Call struct {
	*mock.Call
}

// ListPools is a helper method to define mock.On call
//   - ctx context.Context
func (_e *FEVMQueries_Expecter) ListPools(ctx interface{}) *FEVMQueries_ListPools_Call {
	return &FEVMQueries_ListPools_Call{Call: _e.mock.On("ListPools", ctx)}
}

func (_c *FEVMQueries_ListPools_Call) Run(run func(ctx context.Context)) *FEVMQueries_ListPools_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FEVMQueries_ListPools_Call) Return(_a0 []common.Address, _a1 error) *FEVMQueries_ListPools_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_ListPools_Call) RunAndReturn(run func(context.Context) ([]common.Address, error)) *FEVMQueries_ListPools_Call {
	_c.Call.Return(run)
	return _c
}

// MaxConsecutiveFaultEpochs provides a mock function with given fields: ctx
func (_m *FEVMQueries) MaxConsecutiveFaultEpochs(ctx context.Context) (*big.Int, error) {
	ret := _m.Called(ctx)

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*big.Int, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *big.Int); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_MaxConsecutiveFaultEpochs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MaxConsecutiveFaultEpochs'
type FEVMQueries_MaxConsecutiveFaultEpochs_Call struct {
	*mock.Call
}

// MaxConsecutiveFaultEpochs is a helper method to define mock.On call
//   - ctx context.Context
func (_e *FEVMQueries_Expecter) MaxConsecutiveFaultEpochs(ctx interface{}) *FEVMQueries_MaxConsecutiveFaultEpochs_Call {
	return &FEVMQueries_MaxConsecutiveFaultEpochs_Call{Call: _e.mock.On("MaxConsecutiveFaultEpochs", ctx)}
}

func (_c *FEVMQueries_MaxConsecutiveFaultEpochs_Call) Run(run func(ctx context.Context)) *FEVMQueries_MaxConsecutiveFaultEpochs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FEVMQueries_MaxConsecutiveFaultEpochs_Call) Return(_a0 *big.Int, _a1 error) *FEVMQueries_MaxConsecutiveFaultEpochs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_MaxConsecutiveFaultEpochs_Call) RunAndReturn(run func(context.Context) (*big.Int, error)) *FEVMQueries_MaxConsecutiveFaultEpochs_Call {
	_c.Call.Return(run)
	return _c
}

// MinerRegistry provides a mock function with given fields:
func (_m *FEVMQueries) MinerRegistry() common.Address {
	ret := _m.Called()

	var r0 common.Address
	if rf, ok := ret.Get(0).(func() common.Address); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	return r0
}

// FEVMQueries_MinerRegistry_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MinerRegistry'
type FEVMQueries_MinerRegistry_Call struct {
	*mock.Call
}

// MinerRegistry is a helper method to define mock.On call
func (_e *FEVMQueries_Expecter) MinerRegistry() *FEVMQueries_MinerRegistry_Call {
	return &FEVMQueries_MinerRegistry_Call{Call: _e.mock.On("MinerRegistry")}
}

func (_c *FEVMQueries_MinerRegistry_Call) Run(run func()) *FEVMQueries_MinerRegistry_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *FEVMQueries_MinerRegistry_Call) Return(_a0 common.Address) *FEVMQueries_MinerRegistry_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *FEVMQueries_MinerRegistry_Call) RunAndReturn(run func() common.Address) *FEVMQueries_MinerRegistry_Call {
	_c.Call.Return(run)
	return _c
}

// MinerRegistryAgentMinersCount provides a mock function with given fields: ctx, agentID
func (_m *FEVMQueries) MinerRegistryAgentMinersCount(ctx context.Context, agentID *big.Int) (*big.Int, error) {
	ret := _m.Called(ctx, agentID)

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *big.Int) (*big.Int, error)); ok {
		return rf(ctx, agentID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *big.Int) *big.Int); ok {
		r0 = rf(ctx, agentID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *big.Int) error); ok {
		r1 = rf(ctx, agentID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_MinerRegistryAgentMinersCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MinerRegistryAgentMinersCount'
type FEVMQueries_MinerRegistryAgentMinersCount_Call struct {
	*mock.Call
}

// MinerRegistryAgentMinersCount is a helper method to define mock.On call
//   - ctx context.Context
//   - agentID *big.Int
func (_e *FEVMQueries_Expecter) MinerRegistryAgentMinersCount(ctx interface{}, agentID interface{}) *FEVMQueries_MinerRegistryAgentMinersCount_Call {
	return &FEVMQueries_MinerRegistryAgentMinersCount_Call{Call: _e.mock.On("MinerRegistryAgentMinersCount", ctx, agentID)}
}

func (_c *FEVMQueries_MinerRegistryAgentMinersCount_Call) Run(run func(ctx context.Context, agentID *big.Int)) *FEVMQueries_MinerRegistryAgentMinersCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*big.Int))
	})
	return _c
}

func (_c *FEVMQueries_MinerRegistryAgentMinersCount_Call) Return(_a0 *big.Int, _a1 error) *FEVMQueries_MinerRegistryAgentMinersCount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_MinerRegistryAgentMinersCount_Call) RunAndReturn(run func(context.Context, *big.Int) (*big.Int, error)) *FEVMQueries_MinerRegistryAgentMinersCount_Call {
	_c.Call.Return(run)
	return _c
}

// MinerRegistryAgentMinersList provides a mock function with given fields: ctx, agentID
func (_m *FEVMQueries) MinerRegistryAgentMinersList(ctx context.Context, agentID *big.Int) ([]address.Address, error) {
	ret := _m.Called(ctx, agentID)

	var r0 []address.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *big.Int) ([]address.Address, error)); ok {
		return rf(ctx, agentID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *big.Int) []address.Address); ok {
		r0 = rf(ctx, agentID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]address.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *big.Int) error); ok {
		r1 = rf(ctx, agentID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_MinerRegistryAgentMinersList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MinerRegistryAgentMinersList'
type FEVMQueries_MinerRegistryAgentMinersList_Call struct {
	*mock.Call
}

// MinerRegistryAgentMinersList is a helper method to define mock.On call
//   - ctx context.Context
//   - agentID *big.Int
func (_e *FEVMQueries_Expecter) MinerRegistryAgentMinersList(ctx interface{}, agentID interface{}) *FEVMQueries_MinerRegistryAgentMinersList_Call {
	return &FEVMQueries_MinerRegistryAgentMinersList_Call{Call: _e.mock.On("MinerRegistryAgentMinersList", ctx, agentID)}
}

func (_c *FEVMQueries_MinerRegistryAgentMinersList_Call) Run(run func(ctx context.Context, agentID *big.Int)) *FEVMQueries_MinerRegistryAgentMinersList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*big.Int))
	})
	return _c
}

func (_c *FEVMQueries_MinerRegistryAgentMinersList_Call) Return(_a0 []address.Address, _a1 error) *FEVMQueries_MinerRegistryAgentMinersList_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_MinerRegistryAgentMinersList_Call) RunAndReturn(run func(context.Context, *big.Int) ([]address.Address, error)) *FEVMQueries_MinerRegistryAgentMinersList_Call {
	_c.Call.Return(run)
	return _c
}

// PoolRegistry provides a mock function with given fields:
func (_m *FEVMQueries) PoolRegistry() common.Address {
	ret := _m.Called()

	var r0 common.Address
	if rf, ok := ret.Get(0).(func() common.Address); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	return r0
}

// FEVMQueries_PoolRegistry_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PoolRegistry'
type FEVMQueries_PoolRegistry_Call struct {
	*mock.Call
}

// PoolRegistry is a helper method to define mock.On call
func (_e *FEVMQueries_Expecter) PoolRegistry() *FEVMQueries_PoolRegistry_Call {
	return &FEVMQueries_PoolRegistry_Call{Call: _e.mock.On("PoolRegistry")}
}

func (_c *FEVMQueries_PoolRegistry_Call) Run(run func()) *FEVMQueries_PoolRegistry_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *FEVMQueries_PoolRegistry_Call) Return(_a0 common.Address) *FEVMQueries_PoolRegistry_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *FEVMQueries_PoolRegistry_Call) RunAndReturn(run func() common.Address) *FEVMQueries_PoolRegistry_Call {
	_c.Call.Return(run)
	return _c
}

// RateModule provides a mock function with given fields:
func (_m *FEVMQueries) RateModule() (common.Address, error) {
	ret := _m.Called()

	var r0 common.Address
	var r1 error
	if rf, ok := ret.Get(0).(func() (common.Address, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() common.Address); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_RateModule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RateModule'
type FEVMQueries_RateModule_Call struct {
	*mock.Call
}

// RateModule is a helper method to define mock.On call
func (_e *FEVMQueries_Expecter) RateModule() *FEVMQueries_RateModule_Call {
	return &FEVMQueries_RateModule_Call{Call: _e.mock.On("RateModule")}
}

func (_c *FEVMQueries_RateModule_Call) Run(run func()) *FEVMQueries_RateModule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *FEVMQueries_RateModule_Call) Return(_a0 common.Address, _a1 error) *FEVMQueries_RateModule_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_RateModule_Call) RunAndReturn(run func() (common.Address, error)) *FEVMQueries_RateModule_Call {
	_c.Call.Return(run)
	return _c
}

// Router provides a mock function with given fields:
func (_m *FEVMQueries) Router() common.Address {
	ret := _m.Called()

	var r0 common.Address
	if rf, ok := ret.Get(0).(func() common.Address); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	return r0
}

// FEVMQueries_Router_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Router'
type FEVMQueries_Router_Call struct {
	*mock.Call
}

// Router is a helper method to define mock.On call
func (_e *FEVMQueries_Expecter) Router() *FEVMQueries_Router_Call {
	return &FEVMQueries_Router_Call{Call: _e.mock.On("Router")}
}

func (_c *FEVMQueries_Router_Call) Run(run func()) *FEVMQueries_Router_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *FEVMQueries_Router_Call) Return(_a0 common.Address) *FEVMQueries_Router_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *FEVMQueries_Router_Call) RunAndReturn(run func() common.Address) *FEVMQueries_Router_Call {
	_c.Call.Return(run)
	return _c
}

// RouterGetRoute provides a mock function with given fields: ctx, route
func (_m *FEVMQueries) RouterGetRoute(ctx context.Context, route constants.Route) (common.Address, error) {
	ret := _m.Called(ctx, route)

	var r0 common.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, constants.Route) (common.Address, error)); ok {
		return rf(ctx, route)
	}
	if rf, ok := ret.Get(0).(func(context.Context, constants.Route) common.Address); ok {
		r0 = rf(ctx, route)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, constants.Route) error); ok {
		r1 = rf(ctx, route)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_RouterGetRoute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RouterGetRoute'
type FEVMQueries_RouterGetRoute_Call struct {
	*mock.Call
}

// RouterGetRoute is a helper method to define mock.On call
//   - ctx context.Context
//   - route constants.Route
func (_e *FEVMQueries_Expecter) RouterGetRoute(ctx interface{}, route interface{}) *FEVMQueries_RouterGetRoute_Call {
	return &FEVMQueries_RouterGetRoute_Call{Call: _e.mock.On("RouterGetRoute", ctx, route)}
}

func (_c *FEVMQueries_RouterGetRoute_Call) Run(run func(ctx context.Context, route constants.Route)) *FEVMQueries_RouterGetRoute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(constants.Route))
	})
	return _c
}

func (_c *FEVMQueries_RouterGetRoute_Call) Return(_a0 common.Address, _a1 error) *FEVMQueries_RouterGetRoute_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_RouterGetRoute_Call) RunAndReturn(run func(context.Context, constants.Route) (common.Address, error)) *FEVMQueries_RouterGetRoute_Call {
	_c.Call.Return(run)
	return _c
}

// RouterOwner provides a mock function with given fields: ctx
func (_m *FEVMQueries) RouterOwner(ctx context.Context) (common.Address, error) {
	ret := _m.Called(ctx)

	var r0 common.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (common.Address, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) common.Address); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_RouterOwner_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RouterOwner'
type FEVMQueries_RouterOwner_Call struct {
	*mock.Call
}

// RouterOwner is a helper method to define mock.On call
//   - ctx context.Context
func (_e *FEVMQueries_Expecter) RouterOwner(ctx interface{}) *FEVMQueries_RouterOwner_Call {
	return &FEVMQueries_RouterOwner_Call{Call: _e.mock.On("RouterOwner", ctx)}
}

func (_c *FEVMQueries_RouterOwner_Call) Run(run func(ctx context.Context)) *FEVMQueries_RouterOwner_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FEVMQueries_RouterOwner_Call) Return(_a0 common.Address, _a1 error) *FEVMQueries_RouterOwner_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_RouterOwner_Call) RunAndReturn(run func(context.Context) (common.Address, error)) *FEVMQueries_RouterOwner_Call {
	_c.Call.Return(run)
	return _c
}

// StateWaitNextTick provides a mock function with given fields: ctx, currentEpochHeight
func (_m *FEVMQueries) StateWaitNextTick(ctx context.Context, currentEpochHeight *big.Int) error {
	ret := _m.Called(ctx, currentEpochHeight)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *big.Int) error); ok {
		r0 = rf(ctx, currentEpochHeight)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FEVMQueries_StateWaitNextTick_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateWaitNextTick'
type FEVMQueries_StateWaitNextTick_Call struct {
	*mock.Call
}

// StateWaitNextTick is a helper method to define mock.On call
//   - ctx context.Context
//   - currentEpochHeight *big.Int
func (_e *FEVMQueries_Expecter) StateWaitNextTick(ctx interface{}, currentEpochHeight interface{}) *FEVMQueries_StateWaitNextTick_Call {
	return &FEVMQueries_StateWaitNextTick_Call{Call: _e.mock.On("StateWaitNextTick", ctx, currentEpochHeight)}
}

func (_c *FEVMQueries_StateWaitNextTick_Call) Run(run func(ctx context.Context, currentEpochHeight *big.Int)) *FEVMQueries_StateWaitNextTick_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*big.Int))
	})
	return _c
}

func (_c *FEVMQueries_StateWaitNextTick_Call) Return(_a0 error) *FEVMQueries_StateWaitNextTick_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *FEVMQueries_StateWaitNextTick_Call) RunAndReturn(run func(context.Context, *big.Int) error) *FEVMQueries_StateWaitNextTick_Call {
	_c.Call.Return(run)
	return _c
}

// StateWaitReceipt provides a mock function with given fields: ctx, txHash
func (_m *FEVMQueries) StateWaitReceipt(ctx context.Context, txHash common.Hash) (*coretypes.Receipt, error) {
	ret := _m.Called(ctx, txHash)

	var r0 *coretypes.Receipt
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Hash) (*coretypes.Receipt, error)); ok {
		return rf(ctx, txHash)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Hash) *coretypes.Receipt); ok {
		r0 = rf(ctx, txHash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.Receipt)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Hash) error); ok {
		r1 = rf(ctx, txHash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_StateWaitReceipt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateWaitReceipt'
type FEVMQueries_StateWaitReceipt_Call struct {
	*mock.Call
}

// StateWaitReceipt is a helper method to define mock.On call
//   - ctx context.Context
//   - txHash common.Hash
func (_e *FEVMQueries_Expecter) StateWaitReceipt(ctx interface{}, txHash interface{}) *FEVMQueries_StateWaitReceipt_Call {
	return &FEVMQueries_StateWaitReceipt_Call{Call: _e.mock.On("StateWaitReceipt", ctx, txHash)}
}

func (_c *FEVMQueries_StateWaitReceipt_Call) Run(run func(ctx context.Context, txHash common.Hash)) *FEVMQueries_StateWaitReceipt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Hash))
	})
	return _c
}

func (_c *FEVMQueries_StateWaitReceipt_Call) Return(_a0 *coretypes.Receipt, _a1 error) *FEVMQueries_StateWaitReceipt_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_StateWaitReceipt_Call) RunAndReturn(run func(context.Context, common.Hash) (*coretypes.Receipt, error)) *FEVMQueries_StateWaitReceipt_Call {
	_c.Call.Return(run)
	return _c
}

// StateWaitTx provides a mock function with given fields: ctx, txHash, ch
func (_m *FEVMQueries) StateWaitTx(ctx context.Context, txHash common.Hash, ch chan *coretypes.Receipt) {
	_m.Called(ctx, txHash, ch)
}

// FEVMQueries_StateWaitTx_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateWaitTx'
type FEVMQueries_StateWaitTx_Call struct {
	*mock.Call
}

// StateWaitTx is a helper method to define mock.On call
//   - ctx context.Context
//   - txHash common.Hash
//   - ch chan *coretypes.Receipt
func (_e *FEVMQueries_Expecter) StateWaitTx(ctx interface{}, txHash interface{}, ch interface{}) *FEVMQueries_StateWaitTx_Call {
	return &FEVMQueries_StateWaitTx_Call{Call: _e.mock.On("StateWaitTx", ctx, txHash, ch)}
}

func (_c *FEVMQueries_StateWaitTx_Call) Run(run func(ctx context.Context, txHash common.Hash, ch chan *coretypes.Receipt)) *FEVMQueries_StateWaitTx_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Hash), args[2].(chan *coretypes.Receipt))
	})
	return _c
}

func (_c *FEVMQueries_StateWaitTx_Call) Return() *FEVMQueries_StateWaitTx_Call {
	_c.Call.Return()
	return _c
}

func (_c *FEVMQueries_StateWaitTx_Call) RunAndReturn(run func(context.Context, common.Hash, chan *coretypes.Receipt)) *FEVMQueries_StateWaitTx_Call {
	_c.Call.Return(run)
	return _c
}

// WFIL provides a mock function with given fields:
func (_m *FEVMQueries) WFIL() common.Address {
	ret := _m.Called()

	var r0 common.Address
	if rf, ok := ret.Get(0).(func() common.Address); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	return r0
}

// FEVMQueries_WFIL_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WFIL'
type FEVMQueries_WFIL_Call struct {
	*mock.Call
}

// WFIL is a helper method to define mock.On call
func (_e *FEVMQueries_Expecter) WFIL() *FEVMQueries_WFIL_Call {
	return &FEVMQueries_WFIL_Call{Call: _e.mock.On("WFIL")}
}

func (_c *FEVMQueries_WFIL_Call) Run(run func()) *FEVMQueries_WFIL_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *FEVMQueries_WFIL_Call) Return(_a0 common.Address) *FEVMQueries_WFIL_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *FEVMQueries_WFIL_Call) RunAndReturn(run func() common.Address) *FEVMQueries_WFIL_Call {
	_c.Call.Return(run)
	return _c
}

// WFILAllowance provides a mock function with given fields: ctx, hodler, spender
func (_m *FEVMQueries) WFILAllowance(ctx context.Context, hodler common.Address, spender common.Address) (*big.Float, error) {
	ret := _m.Called(ctx, hodler, spender)

	var r0 *big.Float
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Address, common.Address) (*big.Float, error)); ok {
		return rf(ctx, hodler, spender)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Address, common.Address) *big.Float); ok {
		r0 = rf(ctx, hodler, spender)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Float)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Address, common.Address) error); ok {
		r1 = rf(ctx, hodler, spender)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_WFILAllowance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WFILAllowance'
type FEVMQueries_WFILAllowance_Call struct {
	*mock.Call
}

// WFILAllowance is a helper method to define mock.On call
//   - ctx context.Context
//   - hodler common.Address
//   - spender common.Address
func (_e *FEVMQueries_Expecter) WFILAllowance(ctx interface{}, hodler interface{}, spender interface{}) *FEVMQueries_WFILAllowance_Call {
	return &FEVMQueries_WFILAllowance_Call{Call: _e.mock.On("WFILAllowance", ctx, hodler, spender)}
}

func (_c *FEVMQueries_WFILAllowance_Call) Run(run func(ctx context.Context, hodler common.Address, spender common.Address)) *FEVMQueries_WFILAllowance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Address), args[2].(common.Address))
	})
	return _c
}

func (_c *FEVMQueries_WFILAllowance_Call) Return(_a0 *big.Float, _a1 error) *FEVMQueries_WFILAllowance_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_WFILAllowance_Call) RunAndReturn(run func(context.Context, common.Address, common.Address) (*big.Float, error)) *FEVMQueries_WFILAllowance_Call {
	_c.Call.Return(run)
	return _c
}

// WFILBalanceOf provides a mock function with given fields: ctx, hodler
func (_m *FEVMQueries) WFILBalanceOf(ctx context.Context, hodler common.Address) (*big.Float, error) {
	ret := _m.Called(ctx, hodler)

	var r0 *big.Float
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) (*big.Float, error)); ok {
		return rf(ctx, hodler)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) *big.Float); ok {
		r0 = rf(ctx, hodler)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Float)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Address) error); ok {
		r1 = rf(ctx, hodler)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_WFILBalanceOf_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WFILBalanceOf'
type FEVMQueries_WFILBalanceOf_Call struct {
	*mock.Call
}

// WFILBalanceOf is a helper method to define mock.On call
//   - ctx context.Context
//   - hodler common.Address
func (_e *FEVMQueries_Expecter) WFILBalanceOf(ctx interface{}, hodler interface{}) *FEVMQueries_WFILBalanceOf_Call {
	return &FEVMQueries_WFILBalanceOf_Call{Call: _e.mock.On("WFILBalanceOf", ctx, hodler)}
}

func (_c *FEVMQueries_WFILBalanceOf_Call) Run(run func(ctx context.Context, hodler common.Address)) *FEVMQueries_WFILBalanceOf_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Address))
	})
	return _c
}

func (_c *FEVMQueries_WFILBalanceOf_Call) Return(_a0 *big.Float, _a1 error) *FEVMQueries_WFILBalanceOf_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_WFILBalanceOf_Call) RunAndReturn(run func(context.Context, common.Address) (*big.Float, error)) *FEVMQueries_WFILBalanceOf_Call {
	_c.Call.Return(run)
	return _c
}

// NewFEVMQueries creates a new instance of FEVMQueries. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewFEVMQueries(t interface {
	mock.TestingT
	Cleanup(func())
}) *FEVMQueries {
	mock := &FEVMQueries{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
