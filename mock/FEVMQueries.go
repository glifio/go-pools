// Code generated by mockery v2.53.5. DO NOT EDIT.

package mock

import (
	address "github.com/filecoin-project/go-address"
	abigen "github.com/glifio/go-pools/abigen"

	big "math/big"

	chaintypes "github.com/filecoin-project/lotus/chain/types"

	common "github.com/ethereum/go-ethereum/common"

	constants "github.com/glifio/go-pools/constants"

	context "context"

	coretypes "github.com/ethereum/go-ethereum/core/types"

	mock "github.com/stretchr/testify/mock"

	types "github.com/glifio/go-pools/types"

	vc "github.com/glifio/go-pools/vc"
)

// FEVMQueries is an autogenerated mock type for the FEVMQueries type
type FEVMQueries struct {
	mock.Mock
}

type FEVMQueries_Expecter struct {
	mock *mock.Mock
}

func (_m *FEVMQueries) EXPECT() *FEVMQueries_Expecter {
	return &FEVMQueries_Expecter{mock: &_m.Mock}
}

// AgentAccount provides a mock function with given fields: ctx, agentAddr, poolID, blockNumber
func (_m *FEVMQueries) AgentAccount(ctx context.Context, agentAddr common.Address, poolID *big.Int, blockNumber *big.Int) (abigen.Account, error) {
	ret := _m.Called(ctx, agentAddr, poolID, blockNumber)

	if len(ret) == 0 {
		panic("no return value specified for AgentAccount")
	}

	var r0 abigen.Account
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Address, *big.Int, *big.Int) (abigen.Account, error)); ok {
		return rf(ctx, agentAddr, poolID, blockNumber)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Address, *big.Int, *big.Int) abigen.Account); ok {
		r0 = rf(ctx, agentAddr, poolID, blockNumber)
	} else {
		r0 = ret.Get(0).(abigen.Account)
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Address, *big.Int, *big.Int) error); ok {
		r1 = rf(ctx, agentAddr, poolID, blockNumber)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_AgentAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentAccount'
type FEVMQueries_AgentAccount_Call struct {
	*mock.Call
}

// AgentAccount is a helper method to define mock.On call
//   - ctx context.Context
//   - agentAddr common.Address
//   - poolID *big.Int
//   - blockNumber *big.Int
func (_e *FEVMQueries_Expecter) AgentAccount(ctx interface{}, agentAddr interface{}, poolID interface{}, blockNumber interface{}) *FEVMQueries_AgentAccount_Call {
	return &FEVMQueries_AgentAccount_Call{Call: _e.mock.On("AgentAccount", ctx, agentAddr, poolID, blockNumber)}
}

func (_c *FEVMQueries_AgentAccount_Call) Run(run func(ctx context.Context, agentAddr common.Address, poolID *big.Int, blockNumber *big.Int)) *FEVMQueries_AgentAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Address), args[2].(*big.Int), args[3].(*big.Int))
	})
	return _c
}

func (_c *FEVMQueries_AgentAccount_Call) Return(_a0 abigen.Account, _a1 error) *FEVMQueries_AgentAccount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_AgentAccount_Call) RunAndReturn(run func(context.Context, common.Address, *big.Int, *big.Int) (abigen.Account, error)) *FEVMQueries_AgentAccount_Call {
	_c.Call.Return(run)
	return _c
}

// AgentAddrIDFromRcpt provides a mock function with given fields: ctx, rcpt
func (_m *FEVMQueries) AgentAddrIDFromRcpt(ctx context.Context, rcpt *coretypes.Receipt) (common.Address, *big.Int, error) {
	ret := _m.Called(ctx, rcpt)

	if len(ret) == 0 {
		panic("no return value specified for AgentAddrIDFromRcpt")
	}

	var r0 common.Address
	var r1 *big.Int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, *coretypes.Receipt) (common.Address, *big.Int, error)); ok {
		return rf(ctx, rcpt)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *coretypes.Receipt) common.Address); ok {
		r0 = rf(ctx, rcpt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *coretypes.Receipt) *big.Int); ok {
		r1 = rf(ctx, rcpt)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*big.Int)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, *coretypes.Receipt) error); ok {
		r2 = rf(ctx, rcpt)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// FEVMQueries_AgentAddrIDFromRcpt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentAddrIDFromRcpt'
type FEVMQueries_AgentAddrIDFromRcpt_Call struct {
	*mock.Call
}

// AgentAddrIDFromRcpt is a helper method to define mock.On call
//   - ctx context.Context
//   - rcpt *coretypes.Receipt
func (_e *FEVMQueries_Expecter) AgentAddrIDFromRcpt(ctx interface{}, rcpt interface{}) *FEVMQueries_AgentAddrIDFromRcpt_Call {
	return &FEVMQueries_AgentAddrIDFromRcpt_Call{Call: _e.mock.On("AgentAddrIDFromRcpt", ctx, rcpt)}
}

func (_c *FEVMQueries_AgentAddrIDFromRcpt_Call) Run(run func(ctx context.Context, rcpt *coretypes.Receipt)) *FEVMQueries_AgentAddrIDFromRcpt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*coretypes.Receipt))
	})
	return _c
}

func (_c *FEVMQueries_AgentAddrIDFromRcpt_Call) Return(_a0 common.Address, _a1 *big.Int, _a2 error) *FEVMQueries_AgentAddrIDFromRcpt_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *FEVMQueries_AgentAddrIDFromRcpt_Call) RunAndReturn(run func(context.Context, *coretypes.Receipt) (common.Address, *big.Int, error)) *FEVMQueries_AgentAddrIDFromRcpt_Call {
	_c.Call.Return(run)
	return _c
}

// AgentAdministrator provides a mock function with given fields: ctx, agentAddr
func (_m *FEVMQueries) AgentAdministrator(ctx context.Context, agentAddr common.Address) (common.Address, error) {
	ret := _m.Called(ctx, agentAddr)

	if len(ret) == 0 {
		panic("no return value specified for AgentAdministrator")
	}

	var r0 common.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) (common.Address, error)); ok {
		return rf(ctx, agentAddr)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) common.Address); ok {
		r0 = rf(ctx, agentAddr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Address) error); ok {
		r1 = rf(ctx, agentAddr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_AgentAdministrator_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentAdministrator'
type FEVMQueries_AgentAdministrator_Call struct {
	*mock.Call
}

// AgentAdministrator is a helper method to define mock.On call
//   - ctx context.Context
//   - agentAddr common.Address
func (_e *FEVMQueries_Expecter) AgentAdministrator(ctx interface{}, agentAddr interface{}) *FEVMQueries_AgentAdministrator_Call {
	return &FEVMQueries_AgentAdministrator_Call{Call: _e.mock.On("AgentAdministrator", ctx, agentAddr)}
}

func (_c *FEVMQueries_AgentAdministrator_Call) Run(run func(ctx context.Context, agentAddr common.Address)) *FEVMQueries_AgentAdministrator_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Address))
	})
	return _c
}

func (_c *FEVMQueries_AgentAdministrator_Call) Return(_a0 common.Address, _a1 error) *FEVMQueries_AgentAdministrator_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_AgentAdministrator_Call) RunAndReturn(run func(context.Context, common.Address) (common.Address, error)) *FEVMQueries_AgentAdministrator_Call {
	_c.Call.Return(run)
	return _c
}

// AgentDebt provides a mock function with given fields: ctx, agentAddr, blockNumber
func (_m *FEVMQueries) AgentDebt(ctx context.Context, agentAddr common.Address, blockNumber *big.Int) (*big.Int, error) {
	ret := _m.Called(ctx, agentAddr, blockNumber)

	if len(ret) == 0 {
		panic("no return value specified for AgentDebt")
	}

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Address, *big.Int) (*big.Int, error)); ok {
		return rf(ctx, agentAddr, blockNumber)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Address, *big.Int) *big.Int); ok {
		r0 = rf(ctx, agentAddr, blockNumber)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Address, *big.Int) error); ok {
		r1 = rf(ctx, agentAddr, blockNumber)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_AgentDebt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentDebt'
type FEVMQueries_AgentDebt_Call struct {
	*mock.Call
}

// AgentDebt is a helper method to define mock.On call
//   - ctx context.Context
//   - agentAddr common.Address
//   - blockNumber *big.Int
func (_e *FEVMQueries_Expecter) AgentDebt(ctx interface{}, agentAddr interface{}, blockNumber interface{}) *FEVMQueries_AgentDebt_Call {
	return &FEVMQueries_AgentDebt_Call{Call: _e.mock.On("AgentDebt", ctx, agentAddr, blockNumber)}
}

func (_c *FEVMQueries_AgentDebt_Call) Run(run func(ctx context.Context, agentAddr common.Address, blockNumber *big.Int)) *FEVMQueries_AgentDebt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Address), args[2].(*big.Int))
	})
	return _c
}

func (_c *FEVMQueries_AgentDebt_Call) Return(_a0 *big.Int, _a1 error) *FEVMQueries_AgentDebt_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_AgentDebt_Call) RunAndReturn(run func(context.Context, common.Address, *big.Int) (*big.Int, error)) *FEVMQueries_AgentDebt_Call {
	_c.Call.Return(run)
	return _c
}

// AgentDefaulted provides a mock function with given fields: ctx, agentAddr
func (_m *FEVMQueries) AgentDefaulted(ctx context.Context, agentAddr common.Address) (bool, error) {
	ret := _m.Called(ctx, agentAddr)

	if len(ret) == 0 {
		panic("no return value specified for AgentDefaulted")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) (bool, error)); ok {
		return rf(ctx, agentAddr)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) bool); ok {
		r0 = rf(ctx, agentAddr)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Address) error); ok {
		r1 = rf(ctx, agentAddr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_AgentDefaulted_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentDefaulted'
type FEVMQueries_AgentDefaulted_Call struct {
	*mock.Call
}

// AgentDefaulted is a helper method to define mock.On call
//   - ctx context.Context
//   - agentAddr common.Address
func (_e *FEVMQueries_Expecter) AgentDefaulted(ctx interface{}, agentAddr interface{}) *FEVMQueries_AgentDefaulted_Call {
	return &FEVMQueries_AgentDefaulted_Call{Call: _e.mock.On("AgentDefaulted", ctx, agentAddr)}
}

func (_c *FEVMQueries_AgentDefaulted_Call) Run(run func(ctx context.Context, agentAddr common.Address)) *FEVMQueries_AgentDefaulted_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Address))
	})
	return _c
}

func (_c *FEVMQueries_AgentDefaulted_Call) Return(_a0 bool, _a1 error) *FEVMQueries_AgentDefaulted_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_AgentDefaulted_Call) RunAndReturn(run func(context.Context, common.Address) (bool, error)) *FEVMQueries_AgentDefaulted_Call {
	_c.Call.Return(run)
	return _c
}

// AgentFactory provides a mock function with no fields
func (_m *FEVMQueries) AgentFactory() common.Address {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for AgentFactory")
	}

	var r0 common.Address
	if rf, ok := ret.Get(0).(func() common.Address); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	return r0
}

// FEVMQueries_AgentFactory_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentFactory'
type FEVMQueries_AgentFactory_Call struct {
	*mock.Call
}

// AgentFactory is a helper method to define mock.On call
func (_e *FEVMQueries_Expecter) AgentFactory() *FEVMQueries_AgentFactory_Call {
	return &FEVMQueries_AgentFactory_Call{Call: _e.mock.On("AgentFactory")}
}

func (_c *FEVMQueries_AgentFactory_Call) Run(run func()) *FEVMQueries_AgentFactory_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *FEVMQueries_AgentFactory_Call) Return(_a0 common.Address) *FEVMQueries_AgentFactory_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *FEVMQueries_AgentFactory_Call) RunAndReturn(run func() common.Address) *FEVMQueries_AgentFactory_Call {
	_c.Call.Return(run)
	return _c
}

// AgentFactoryAgentCount provides a mock function with given fields: ctx, blockNumber
func (_m *FEVMQueries) AgentFactoryAgentCount(ctx context.Context, blockNumber *big.Int) (*big.Int, error) {
	ret := _m.Called(ctx, blockNumber)

	if len(ret) == 0 {
		panic("no return value specified for AgentFactoryAgentCount")
	}

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *big.Int) (*big.Int, error)); ok {
		return rf(ctx, blockNumber)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *big.Int) *big.Int); ok {
		r0 = rf(ctx, blockNumber)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *big.Int) error); ok {
		r1 = rf(ctx, blockNumber)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_AgentFactoryAgentCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentFactoryAgentCount'
type FEVMQueries_AgentFactoryAgentCount_Call struct {
	*mock.Call
}

// AgentFactoryAgentCount is a helper method to define mock.On call
//   - ctx context.Context
//   - blockNumber *big.Int
func (_e *FEVMQueries_Expecter) AgentFactoryAgentCount(ctx interface{}, blockNumber interface{}) *FEVMQueries_AgentFactoryAgentCount_Call {
	return &FEVMQueries_AgentFactoryAgentCount_Call{Call: _e.mock.On("AgentFactoryAgentCount", ctx, blockNumber)}
}

func (_c *FEVMQueries_AgentFactoryAgentCount_Call) Run(run func(ctx context.Context, blockNumber *big.Int)) *FEVMQueries_AgentFactoryAgentCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*big.Int))
	})
	return _c
}

func (_c *FEVMQueries_AgentFactoryAgentCount_Call) Return(_a0 *big.Int, _a1 error) *FEVMQueries_AgentFactoryAgentCount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_AgentFactoryAgentCount_Call) RunAndReturn(run func(context.Context, *big.Int) (*big.Int, error)) *FEVMQueries_AgentFactoryAgentCount_Call {
	_c.Call.Return(run)
	return _c
}

// AgentID provides a mock function with given fields: ctx, agentAddr
func (_m *FEVMQueries) AgentID(ctx context.Context, agentAddr common.Address) (*big.Int, error) {
	ret := _m.Called(ctx, agentAddr)

	if len(ret) == 0 {
		panic("no return value specified for AgentID")
	}

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) (*big.Int, error)); ok {
		return rf(ctx, agentAddr)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) *big.Int); ok {
		r0 = rf(ctx, agentAddr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Address) error); ok {
		r1 = rf(ctx, agentAddr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_AgentID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentID'
type FEVMQueries_AgentID_Call struct {
	*mock.Call
}

// AgentID is a helper method to define mock.On call
//   - ctx context.Context
//   - agentAddr common.Address
func (_e *FEVMQueries_Expecter) AgentID(ctx interface{}, agentAddr interface{}) *FEVMQueries_AgentID_Call {
	return &FEVMQueries_AgentID_Call{Call: _e.mock.On("AgentID", ctx, agentAddr)}
}

func (_c *FEVMQueries_AgentID_Call) Run(run func(ctx context.Context, agentAddr common.Address)) *FEVMQueries_AgentID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Address))
	})
	return _c
}

func (_c *FEVMQueries_AgentID_Call) Return(_a0 *big.Int, _a1 error) *FEVMQueries_AgentID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_AgentID_Call) RunAndReturn(run func(context.Context, common.Address) (*big.Int, error)) *FEVMQueries_AgentID_Call {
	_c.Call.Return(run)
	return _c
}

// AgentInterestOwed provides a mock function with given fields: ctx, agentAddr, blockNumber
func (_m *FEVMQueries) AgentInterestOwed(ctx context.Context, agentAddr common.Address, blockNumber *big.Int) (*big.Int, error) {
	ret := _m.Called(ctx, agentAddr, blockNumber)

	if len(ret) == 0 {
		panic("no return value specified for AgentInterestOwed")
	}

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Address, *big.Int) (*big.Int, error)); ok {
		return rf(ctx, agentAddr, blockNumber)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Address, *big.Int) *big.Int); ok {
		r0 = rf(ctx, agentAddr, blockNumber)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Address, *big.Int) error); ok {
		r1 = rf(ctx, agentAddr, blockNumber)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_AgentInterestOwed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentInterestOwed'
type FEVMQueries_AgentInterestOwed_Call struct {
	*mock.Call
}

// AgentInterestOwed is a helper method to define mock.On call
//   - ctx context.Context
//   - agentAddr common.Address
//   - blockNumber *big.Int
func (_e *FEVMQueries_Expecter) AgentInterestOwed(ctx interface{}, agentAddr interface{}, blockNumber interface{}) *FEVMQueries_AgentInterestOwed_Call {
	return &FEVMQueries_AgentInterestOwed_Call{Call: _e.mock.On("AgentInterestOwed", ctx, agentAddr, blockNumber)}
}

func (_c *FEVMQueries_AgentInterestOwed_Call) Run(run func(ctx context.Context, agentAddr common.Address, blockNumber *big.Int)) *FEVMQueries_AgentInterestOwed_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Address), args[2].(*big.Int))
	})
	return _c
}

func (_c *FEVMQueries_AgentInterestOwed_Call) Return(_a0 *big.Int, _a1 error) *FEVMQueries_AgentInterestOwed_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_AgentInterestOwed_Call) RunAndReturn(run func(context.Context, common.Address, *big.Int) (*big.Int, error)) *FEVMQueries_AgentInterestOwed_Call {
	_c.Call.Return(run)
	return _c
}

// AgentIsValid provides a mock function with given fields: ctx, agentAddr
func (_m *FEVMQueries) AgentIsValid(ctx context.Context, agentAddr common.Address) (bool, error) {
	ret := _m.Called(ctx, agentAddr)

	if len(ret) == 0 {
		panic("no return value specified for AgentIsValid")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) (bool, error)); ok {
		return rf(ctx, agentAddr)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) bool); ok {
		r0 = rf(ctx, agentAddr)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Address) error); ok {
		r1 = rf(ctx, agentAddr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_AgentIsValid_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentIsValid'
type FEVMQueries_AgentIsValid_Call struct {
	*mock.Call
}

// AgentIsValid is a helper method to define mock.On call
//   - ctx context.Context
//   - agentAddr common.Address
func (_e *FEVMQueries_Expecter) AgentIsValid(ctx interface{}, agentAddr interface{}) *FEVMQueries_AgentIsValid_Call {
	return &FEVMQueries_AgentIsValid_Call{Call: _e.mock.On("AgentIsValid", ctx, agentAddr)}
}

func (_c *FEVMQueries_AgentIsValid_Call) Run(run func(ctx context.Context, agentAddr common.Address)) *FEVMQueries_AgentIsValid_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Address))
	})
	return _c
}

func (_c *FEVMQueries_AgentIsValid_Call) Return(_a0 bool, _a1 error) *FEVMQueries_AgentIsValid_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_AgentIsValid_Call) RunAndReturn(run func(context.Context, common.Address) (bool, error)) *FEVMQueries_AgentIsValid_Call {
	_c.Call.Return(run)
	return _c
}

// AgentLiquidAssets provides a mock function with given fields: ctx, agentAddr, blockNumber
func (_m *FEVMQueries) AgentLiquidAssets(ctx context.Context, agentAddr common.Address, blockNumber *big.Int) (*big.Int, error) {
	ret := _m.Called(ctx, agentAddr, blockNumber)

	if len(ret) == 0 {
		panic("no return value specified for AgentLiquidAssets")
	}

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Address, *big.Int) (*big.Int, error)); ok {
		return rf(ctx, agentAddr, blockNumber)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Address, *big.Int) *big.Int); ok {
		r0 = rf(ctx, agentAddr, blockNumber)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Address, *big.Int) error); ok {
		r1 = rf(ctx, agentAddr, blockNumber)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_AgentLiquidAssets_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentLiquidAssets'
type FEVMQueries_AgentLiquidAssets_Call struct {
	*mock.Call
}

// AgentLiquidAssets is a helper method to define mock.On call
//   - ctx context.Context
//   - agentAddr common.Address
//   - blockNumber *big.Int
func (_e *FEVMQueries_Expecter) AgentLiquidAssets(ctx interface{}, agentAddr interface{}, blockNumber interface{}) *FEVMQueries_AgentLiquidAssets_Call {
	return &FEVMQueries_AgentLiquidAssets_Call{Call: _e.mock.On("AgentLiquidAssets", ctx, agentAddr, blockNumber)}
}

func (_c *FEVMQueries_AgentLiquidAssets_Call) Run(run func(ctx context.Context, agentAddr common.Address, blockNumber *big.Int)) *FEVMQueries_AgentLiquidAssets_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Address), args[2].(*big.Int))
	})
	return _c
}

func (_c *FEVMQueries_AgentLiquidAssets_Call) Return(_a0 *big.Int, _a1 error) *FEVMQueries_AgentLiquidAssets_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_AgentLiquidAssets_Call) RunAndReturn(run func(context.Context, common.Address, *big.Int) (*big.Int, error)) *FEVMQueries_AgentLiquidAssets_Call {
	_c.Call.Return(run)
	return _c
}

// AgentMiners provides a mock function with given fields: ctx, agentAddr, blockNumber
func (_m *FEVMQueries) AgentMiners(ctx context.Context, agentAddr common.Address, blockNumber *big.Int) ([]address.Address, error) {
	ret := _m.Called(ctx, agentAddr, blockNumber)

	if len(ret) == 0 {
		panic("no return value specified for AgentMiners")
	}

	var r0 []address.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Address, *big.Int) ([]address.Address, error)); ok {
		return rf(ctx, agentAddr, blockNumber)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Address, *big.Int) []address.Address); ok {
		r0 = rf(ctx, agentAddr, blockNumber)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]address.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Address, *big.Int) error); ok {
		r1 = rf(ctx, agentAddr, blockNumber)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_AgentMiners_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentMiners'
type FEVMQueries_AgentMiners_Call struct {
	*mock.Call
}

// AgentMiners is a helper method to define mock.On call
//   - ctx context.Context
//   - agentAddr common.Address
//   - blockNumber *big.Int
func (_e *FEVMQueries_Expecter) AgentMiners(ctx interface{}, agentAddr interface{}, blockNumber interface{}) *FEVMQueries_AgentMiners_Call {
	return &FEVMQueries_AgentMiners_Call{Call: _e.mock.On("AgentMiners", ctx, agentAddr, blockNumber)}
}

func (_c *FEVMQueries_AgentMiners_Call) Run(run func(ctx context.Context, agentAddr common.Address, blockNumber *big.Int)) *FEVMQueries_AgentMiners_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Address), args[2].(*big.Int))
	})
	return _c
}

func (_c *FEVMQueries_AgentMiners_Call) Return(_a0 []address.Address, _a1 error) *FEVMQueries_AgentMiners_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_AgentMiners_Call) RunAndReturn(run func(context.Context, common.Address, *big.Int) ([]address.Address, error)) *FEVMQueries_AgentMiners_Call {
	_c.Call.Return(run)
	return _c
}

// AgentOperator provides a mock function with given fields: ctx, agentAddr
func (_m *FEVMQueries) AgentOperator(ctx context.Context, agentAddr common.Address) (common.Address, error) {
	ret := _m.Called(ctx, agentAddr)

	if len(ret) == 0 {
		panic("no return value specified for AgentOperator")
	}

	var r0 common.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) (common.Address, error)); ok {
		return rf(ctx, agentAddr)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) common.Address); ok {
		r0 = rf(ctx, agentAddr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Address) error); ok {
		r1 = rf(ctx, agentAddr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_AgentOperator_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentOperator'
type FEVMQueries_AgentOperator_Call struct {
	*mock.Call
}

// AgentOperator is a helper method to define mock.On call
//   - ctx context.Context
//   - agentAddr common.Address
func (_e *FEVMQueries_Expecter) AgentOperator(ctx interface{}, agentAddr interface{}) *FEVMQueries_AgentOperator_Call {
	return &FEVMQueries_AgentOperator_Call{Call: _e.mock.On("AgentOperator", ctx, agentAddr)}
}

func (_c *FEVMQueries_AgentOperator_Call) Run(run func(ctx context.Context, agentAddr common.Address)) *FEVMQueries_AgentOperator_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Address))
	})
	return _c
}

func (_c *FEVMQueries_AgentOperator_Call) Return(_a0 common.Address, _a1 error) *FEVMQueries_AgentOperator_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_AgentOperator_Call) RunAndReturn(run func(context.Context, common.Address) (common.Address, error)) *FEVMQueries_AgentOperator_Call {
	_c.Call.Return(run)
	return _c
}

// AgentOwner provides a mock function with given fields: ctx, agentAddr
func (_m *FEVMQueries) AgentOwner(ctx context.Context, agentAddr common.Address) (common.Address, error) {
	ret := _m.Called(ctx, agentAddr)

	if len(ret) == 0 {
		panic("no return value specified for AgentOwner")
	}

	var r0 common.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) (common.Address, error)); ok {
		return rf(ctx, agentAddr)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) common.Address); ok {
		r0 = rf(ctx, agentAddr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Address) error); ok {
		r1 = rf(ctx, agentAddr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_AgentOwner_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentOwner'
type FEVMQueries_AgentOwner_Call struct {
	*mock.Call
}

// AgentOwner is a helper method to define mock.On call
//   - ctx context.Context
//   - agentAddr common.Address
func (_e *FEVMQueries_Expecter) AgentOwner(ctx interface{}, agentAddr interface{}) *FEVMQueries_AgentOwner_Call {
	return &FEVMQueries_AgentOwner_Call{Call: _e.mock.On("AgentOwner", ctx, agentAddr)}
}

func (_c *FEVMQueries_AgentOwner_Call) Run(run func(ctx context.Context, agentAddr common.Address)) *FEVMQueries_AgentOwner_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Address))
	})
	return _c
}

func (_c *FEVMQueries_AgentOwner_Call) Return(_a0 common.Address, _a1 error) *FEVMQueries_AgentOwner_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_AgentOwner_Call) RunAndReturn(run func(context.Context, common.Address) (common.Address, error)) *FEVMQueries_AgentOwner_Call {
	_c.Call.Return(run)
	return _c
}

// AgentPolice provides a mock function with no fields
func (_m *FEVMQueries) AgentPolice() common.Address {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for AgentPolice")
	}

	var r0 common.Address
	if rf, ok := ret.Get(0).(func() common.Address); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	return r0
}

// FEVMQueries_AgentPolice_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentPolice'
type FEVMQueries_AgentPolice_Call struct {
	*mock.Call
}

// AgentPolice is a helper method to define mock.On call
func (_e *FEVMQueries_Expecter) AgentPolice() *FEVMQueries_AgentPolice_Call {
	return &FEVMQueries_AgentPolice_Call{Call: _e.mock.On("AgentPolice")}
}

func (_c *FEVMQueries_AgentPolice_Call) Run(run func()) *FEVMQueries_AgentPolice_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *FEVMQueries_AgentPolice_Call) Return(_a0 common.Address) *FEVMQueries_AgentPolice_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *FEVMQueries_AgentPolice_Call) RunAndReturn(run func() common.Address) *FEVMQueries_AgentPolice_Call {
	_c.Call.Return(run)
	return _c
}

// AgentPrincipal provides a mock function with given fields: ctx, agentAddr, blockNumber
func (_m *FEVMQueries) AgentPrincipal(ctx context.Context, agentAddr common.Address, blockNumber *big.Int) (*big.Int, error) {
	ret := _m.Called(ctx, agentAddr, blockNumber)

	if len(ret) == 0 {
		panic("no return value specified for AgentPrincipal")
	}

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Address, *big.Int) (*big.Int, error)); ok {
		return rf(ctx, agentAddr, blockNumber)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Address, *big.Int) *big.Int); ok {
		r0 = rf(ctx, agentAddr, blockNumber)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Address, *big.Int) error); ok {
		r1 = rf(ctx, agentAddr, blockNumber)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_AgentPrincipal_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentPrincipal'
type FEVMQueries_AgentPrincipal_Call struct {
	*mock.Call
}

// AgentPrincipal is a helper method to define mock.On call
//   - ctx context.Context
//   - agentAddr common.Address
//   - blockNumber *big.Int
func (_e *FEVMQueries_Expecter) AgentPrincipal(ctx interface{}, agentAddr interface{}, blockNumber interface{}) *FEVMQueries_AgentPrincipal_Call {
	return &FEVMQueries_AgentPrincipal_Call{Call: _e.mock.On("AgentPrincipal", ctx, agentAddr, blockNumber)}
}

func (_c *FEVMQueries_AgentPrincipal_Call) Run(run func(ctx context.Context, agentAddr common.Address, blockNumber *big.Int)) *FEVMQueries_AgentPrincipal_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Address), args[2].(*big.Int))
	})
	return _c
}

func (_c *FEVMQueries_AgentPrincipal_Call) Return(_a0 *big.Int, _a1 error) *FEVMQueries_AgentPrincipal_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_AgentPrincipal_Call) RunAndReturn(run func(context.Context, common.Address, *big.Int) (*big.Int, error)) *FEVMQueries_AgentPrincipal_Call {
	_c.Call.Return(run)
	return _c
}

// AgentRequester provides a mock function with given fields: ctx, agentAddr
func (_m *FEVMQueries) AgentRequester(ctx context.Context, agentAddr common.Address) (common.Address, error) {
	ret := _m.Called(ctx, agentAddr)

	if len(ret) == 0 {
		panic("no return value specified for AgentRequester")
	}

	var r0 common.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) (common.Address, error)); ok {
		return rf(ctx, agentAddr)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) common.Address); ok {
		r0 = rf(ctx, agentAddr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Address) error); ok {
		r1 = rf(ctx, agentAddr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_AgentRequester_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentRequester'
type FEVMQueries_AgentRequester_Call struct {
	*mock.Call
}

// AgentRequester is a helper method to define mock.On call
//   - ctx context.Context
//   - agentAddr common.Address
func (_e *FEVMQueries_Expecter) AgentRequester(ctx interface{}, agentAddr interface{}) *FEVMQueries_AgentRequester_Call {
	return &FEVMQueries_AgentRequester_Call{Call: _e.mock.On("AgentRequester", ctx, agentAddr)}
}

func (_c *FEVMQueries_AgentRequester_Call) Run(run func(ctx context.Context, agentAddr common.Address)) *FEVMQueries_AgentRequester_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Address))
	})
	return _c
}

func (_c *FEVMQueries_AgentRequester_Call) Return(_a0 common.Address, _a1 error) *FEVMQueries_AgentRequester_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_AgentRequester_Call) RunAndReturn(run func(context.Context, common.Address) (common.Address, error)) *FEVMQueries_AgentRequester_Call {
	_c.Call.Return(run)
	return _c
}

// AgentVersion provides a mock function with given fields: ctx, agentAddr
func (_m *FEVMQueries) AgentVersion(ctx context.Context, agentAddr common.Address) (uint8, uint8, error) {
	ret := _m.Called(ctx, agentAddr)

	if len(ret) == 0 {
		panic("no return value specified for AgentVersion")
	}

	var r0 uint8
	var r1 uint8
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) (uint8, uint8, error)); ok {
		return rf(ctx, agentAddr)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) uint8); ok {
		r0 = rf(ctx, agentAddr)
	} else {
		r0 = ret.Get(0).(uint8)
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Address) uint8); ok {
		r1 = rf(ctx, agentAddr)
	} else {
		r1 = ret.Get(1).(uint8)
	}

	if rf, ok := ret.Get(2).(func(context.Context, common.Address) error); ok {
		r2 = rf(ctx, agentAddr)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// FEVMQueries_AgentVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AgentVersion'
type FEVMQueries_AgentVersion_Call struct {
	*mock.Call
}

// AgentVersion is a helper method to define mock.On call
//   - ctx context.Context
//   - agentAddr common.Address
func (_e *FEVMQueries_Expecter) AgentVersion(ctx interface{}, agentAddr interface{}) *FEVMQueries_AgentVersion_Call {
	return &FEVMQueries_AgentVersion_Call{Call: _e.mock.On("AgentVersion", ctx, agentAddr)}
}

func (_c *FEVMQueries_AgentVersion_Call) Run(run func(ctx context.Context, agentAddr common.Address)) *FEVMQueries_AgentVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Address))
	})
	return _c
}

func (_c *FEVMQueries_AgentVersion_Call) Return(_a0 uint8, _a1 uint8, _a2 error) *FEVMQueries_AgentVersion_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *FEVMQueries_AgentVersion_Call) RunAndReturn(run func(context.Context, common.Address) (uint8, uint8, error)) *FEVMQueries_AgentVersion_Call {
	_c.Call.Return(run)
	return _c
}

// ChainGetNonce provides a mock function with given fields: ctx, fromAddr
func (_m *FEVMQueries) ChainGetNonce(ctx context.Context, fromAddr common.Address) (*big.Int, error) {
	ret := _m.Called(ctx, fromAddr)

	if len(ret) == 0 {
		panic("no return value specified for ChainGetNonce")
	}

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) (*big.Int, error)); ok {
		return rf(ctx, fromAddr)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) *big.Int); ok {
		r0 = rf(ctx, fromAddr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Address) error); ok {
		r1 = rf(ctx, fromAddr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_ChainGetNonce_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChainGetNonce'
type FEVMQueries_ChainGetNonce_Call struct {
	*mock.Call
}

// ChainGetNonce is a helper method to define mock.On call
//   - ctx context.Context
//   - fromAddr common.Address
func (_e *FEVMQueries_Expecter) ChainGetNonce(ctx interface{}, fromAddr interface{}) *FEVMQueries_ChainGetNonce_Call {
	return &FEVMQueries_ChainGetNonce_Call{Call: _e.mock.On("ChainGetNonce", ctx, fromAddr)}
}

func (_c *FEVMQueries_ChainGetNonce_Call) Run(run func(ctx context.Context, fromAddr common.Address)) *FEVMQueries_ChainGetNonce_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Address))
	})
	return _c
}

func (_c *FEVMQueries_ChainGetNonce_Call) Return(_a0 *big.Int, _a1 error) *FEVMQueries_ChainGetNonce_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_ChainGetNonce_Call) RunAndReturn(run func(context.Context, common.Address) (*big.Int, error)) *FEVMQueries_ChainGetNonce_Call {
	_c.Call.Return(run)
	return _c
}

// ChainHead provides a mock function with given fields: ctx
func (_m *FEVMQueries) ChainHead(ctx context.Context) (*chaintypes.TipSet, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ChainHead")
	}

	var r0 *chaintypes.TipSet
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*chaintypes.TipSet, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *chaintypes.TipSet); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*chaintypes.TipSet)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_ChainHead_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChainHead'
type FEVMQueries_ChainHead_Call struct {
	*mock.Call
}

// ChainHead is a helper method to define mock.On call
//   - ctx context.Context
func (_e *FEVMQueries_Expecter) ChainHead(ctx interface{}) *FEVMQueries_ChainHead_Call {
	return &FEVMQueries_ChainHead_Call{Call: _e.mock.On("ChainHead", ctx)}
}

func (_c *FEVMQueries_ChainHead_Call) Run(run func(ctx context.Context)) *FEVMQueries_ChainHead_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FEVMQueries_ChainHead_Call) Return(_a0 *chaintypes.TipSet, _a1 error) *FEVMQueries_ChainHead_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_ChainHead_Call) RunAndReturn(run func(context.Context) (*chaintypes.TipSet, error)) *FEVMQueries_ChainHead_Call {
	_c.Call.Return(run)
	return _c
}

// ChainHeight provides a mock function with given fields: ctx
func (_m *FEVMQueries) ChainHeight(ctx context.Context) (*big.Int, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ChainHeight")
	}

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*big.Int, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *big.Int); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_ChainHeight_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChainHeight'
type FEVMQueries_ChainHeight_Call struct {
	*mock.Call
}

// ChainHeight is a helper method to define mock.On call
//   - ctx context.Context
func (_e *FEVMQueries_Expecter) ChainHeight(ctx interface{}) *FEVMQueries_ChainHeight_Call {
	return &FEVMQueries_ChainHeight_Call{Call: _e.mock.On("ChainHeight", ctx)}
}

func (_c *FEVMQueries_ChainHeight_Call) Run(run func(ctx context.Context)) *FEVMQueries_ChainHeight_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FEVMQueries_ChainHeight_Call) Return(_a0 *big.Int, _a1 error) *FEVMQueries_ChainHeight_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_ChainHeight_Call) RunAndReturn(run func(context.Context) (*big.Int, error)) *FEVMQueries_ChainHeight_Call {
	_c.Call.Return(run)
	return _c
}

// ChainID provides a mock function with no fields
func (_m *FEVMQueries) ChainID() *big.Int {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for ChainID")
	}

	var r0 *big.Int
	if rf, ok := ret.Get(0).(func() *big.Int); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	return r0
}

// FEVMQueries_ChainID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChainID'
type FEVMQueries_ChainID_Call struct {
	*mock.Call
}

// ChainID is a helper method to define mock.On call
func (_e *FEVMQueries_Expecter) ChainID() *FEVMQueries_ChainID_Call {
	return &FEVMQueries_ChainID_Call{Call: _e.mock.On("ChainID")}
}

func (_c *FEVMQueries_ChainID_Call) Run(run func()) *FEVMQueries_ChainID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *FEVMQueries_ChainID_Call) Return(_a0 *big.Int) *FEVMQueries_ChainID_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *FEVMQueries_ChainID_Call) RunAndReturn(run func() *big.Int) *FEVMQueries_ChainID_Call {
	_c.Call.Return(run)
	return _c
}

// CredentialUsedEpoch provides a mock function with given fields: ctx, _a1, blockNumber
func (_m *FEVMQueries) CredentialUsedEpoch(ctx context.Context, _a1 abigen.VerifiableCredential, blockNumber *big.Int) (*big.Int, error) {
	ret := _m.Called(ctx, _a1, blockNumber)

	if len(ret) == 0 {
		panic("no return value specified for CredentialUsedEpoch")
	}

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, abigen.VerifiableCredential, *big.Int) (*big.Int, error)); ok {
		return rf(ctx, _a1, blockNumber)
	}
	if rf, ok := ret.Get(0).(func(context.Context, abigen.VerifiableCredential, *big.Int) *big.Int); ok {
		r0 = rf(ctx, _a1, blockNumber)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, abigen.VerifiableCredential, *big.Int) error); ok {
		r1 = rf(ctx, _a1, blockNumber)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_CredentialUsedEpoch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CredentialUsedEpoch'
type FEVMQueries_CredentialUsedEpoch_Call struct {
	*mock.Call
}

// CredentialUsedEpoch is a helper method to define mock.On call
//   - ctx context.Context
//   - _a1 abigen.VerifiableCredential
//   - blockNumber *big.Int
func (_e *FEVMQueries_Expecter) CredentialUsedEpoch(ctx interface{}, _a1 interface{}, blockNumber interface{}) *FEVMQueries_CredentialUsedEpoch_Call {
	return &FEVMQueries_CredentialUsedEpoch_Call{Call: _e.mock.On("CredentialUsedEpoch", ctx, _a1, blockNumber)}
}

func (_c *FEVMQueries_CredentialUsedEpoch_Call) Run(run func(ctx context.Context, _a1 abigen.VerifiableCredential, blockNumber *big.Int)) *FEVMQueries_CredentialUsedEpoch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(abigen.VerifiableCredential), args[2].(*big.Int))
	})
	return _c
}

func (_c *FEVMQueries_CredentialUsedEpoch_Call) Return(_a0 *big.Int, _a1 error) *FEVMQueries_CredentialUsedEpoch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_CredentialUsedEpoch_Call) RunAndReturn(run func(context.Context, abigen.VerifiableCredential, *big.Int) (*big.Int, error)) *FEVMQueries_CredentialUsedEpoch_Call {
	_c.Call.Return(run)
	return _c
}

// CredentialValidityPeriod provides a mock function with given fields: ctx
func (_m *FEVMQueries) CredentialValidityPeriod(ctx context.Context) (*big.Int, *big.Int, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for CredentialValidityPeriod")
	}

	var r0 *big.Int
	var r1 *big.Int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context) (*big.Int, *big.Int, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *big.Int); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) *big.Int); ok {
		r1 = rf(ctx)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*big.Int)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context) error); ok {
		r2 = rf(ctx)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// FEVMQueries_CredentialValidityPeriod_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CredentialValidityPeriod'
type FEVMQueries_CredentialValidityPeriod_Call struct {
	*mock.Call
}

// CredentialValidityPeriod is a helper method to define mock.On call
//   - ctx context.Context
func (_e *FEVMQueries_Expecter) CredentialValidityPeriod(ctx interface{}) *FEVMQueries_CredentialValidityPeriod_Call {
	return &FEVMQueries_CredentialValidityPeriod_Call{Call: _e.mock.On("CredentialValidityPeriod", ctx)}
}

func (_c *FEVMQueries_CredentialValidityPeriod_Call) Run(run func(ctx context.Context)) *FEVMQueries_CredentialValidityPeriod_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FEVMQueries_CredentialValidityPeriod_Call) Return(_a0 *big.Int, _a1 *big.Int, _a2 error) *FEVMQueries_CredentialValidityPeriod_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *FEVMQueries_CredentialValidityPeriod_Call) RunAndReturn(run func(context.Context) (*big.Int, *big.Int, error)) *FEVMQueries_CredentialValidityPeriod_Call {
	_c.Call.Return(run)
	return _c
}

// DelegatedClaimsCampaigns provides a mock function with no fields
func (_m *FEVMQueries) DelegatedClaimsCampaigns() common.Address {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for DelegatedClaimsCampaigns")
	}

	var r0 common.Address
	if rf, ok := ret.Get(0).(func() common.Address); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	return r0
}

// FEVMQueries_DelegatedClaimsCampaigns_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DelegatedClaimsCampaigns'
type FEVMQueries_DelegatedClaimsCampaigns_Call struct {
	*mock.Call
}

// DelegatedClaimsCampaigns is a helper method to define mock.On call
func (_e *FEVMQueries_Expecter) DelegatedClaimsCampaigns() *FEVMQueries_DelegatedClaimsCampaigns_Call {
	return &FEVMQueries_DelegatedClaimsCampaigns_Call{Call: _e.mock.On("DelegatedClaimsCampaigns")}
}

func (_c *FEVMQueries_DelegatedClaimsCampaigns_Call) Run(run func()) *FEVMQueries_DelegatedClaimsCampaigns_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *FEVMQueries_DelegatedClaimsCampaigns_Call) Return(_a0 common.Address) *FEVMQueries_DelegatedClaimsCampaigns_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *FEVMQueries_DelegatedClaimsCampaigns_Call) RunAndReturn(run func() common.Address) *FEVMQueries_DelegatedClaimsCampaigns_Call {
	_c.Call.Return(run)
	return _c
}

// GLF provides a mock function with no fields
func (_m *FEVMQueries) GLF() common.Address {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GLF")
	}

	var r0 common.Address
	if rf, ok := ret.Get(0).(func() common.Address); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	return r0
}

// FEVMQueries_GLF_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GLF'
type FEVMQueries_GLF_Call struct {
	*mock.Call
}

// GLF is a helper method to define mock.On call
func (_e *FEVMQueries_Expecter) GLF() *FEVMQueries_GLF_Call {
	return &FEVMQueries_GLF_Call{Call: _e.mock.On("GLF")}
}

func (_c *FEVMQueries_GLF_Call) Run(run func()) *FEVMQueries_GLF_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *FEVMQueries_GLF_Call) Return(_a0 common.Address) *FEVMQueries_GLF_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *FEVMQueries_GLF_Call) RunAndReturn(run func() common.Address) *FEVMQueries_GLF_Call {
	_c.Call.Return(run)
	return _c
}

// Governor provides a mock function with no fields
func (_m *FEVMQueries) Governor() common.Address {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Governor")
	}

	var r0 common.Address
	if rf, ok := ret.Get(0).(func() common.Address); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	return r0
}

// FEVMQueries_Governor_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Governor'
type FEVMQueries_Governor_Call struct {
	*mock.Call
}

// Governor is a helper method to define mock.On call
func (_e *FEVMQueries_Expecter) Governor() *FEVMQueries_Governor_Call {
	return &FEVMQueries_Governor_Call{Call: _e.mock.On("Governor")}
}

func (_c *FEVMQueries_Governor_Call) Run(run func()) *FEVMQueries_Governor_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *FEVMQueries_Governor_Call) Return(_a0 common.Address) *FEVMQueries_Governor_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *FEVMQueries_Governor_Call) RunAndReturn(run func() common.Address) *FEVMQueries_Governor_Call {
	_c.Call.Return(run)
	return _c
}

// IFIL provides a mock function with no fields
func (_m *FEVMQueries) IFIL() common.Address {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for IFIL")
	}

	var r0 common.Address
	if rf, ok := ret.Get(0).(func() common.Address); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	return r0
}

// FEVMQueries_IFIL_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IFIL'
type FEVMQueries_IFIL_Call struct {
	*mock.Call
}

// IFIL is a helper method to define mock.On call
func (_e *FEVMQueries_Expecter) IFIL() *FEVMQueries_IFIL_Call {
	return &FEVMQueries_IFIL_Call{Call: _e.mock.On("IFIL")}
}

func (_c *FEVMQueries_IFIL_Call) Run(run func()) *FEVMQueries_IFIL_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *FEVMQueries_IFIL_Call) Return(_a0 common.Address) *FEVMQueries_IFIL_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *FEVMQueries_IFIL_Call) RunAndReturn(run func() common.Address) *FEVMQueries_IFIL_Call {
	_c.Call.Return(run)
	return _c
}

// IFILBalanceOf provides a mock function with given fields: ctx, hodler
func (_m *FEVMQueries) IFILBalanceOf(ctx context.Context, hodler common.Address) (*big.Float, error) {
	ret := _m.Called(ctx, hodler)

	if len(ret) == 0 {
		panic("no return value specified for IFILBalanceOf")
	}

	var r0 *big.Float
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) (*big.Float, error)); ok {
		return rf(ctx, hodler)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) *big.Float); ok {
		r0 = rf(ctx, hodler)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Float)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Address) error); ok {
		r1 = rf(ctx, hodler)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_IFILBalanceOf_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IFILBalanceOf'
type FEVMQueries_IFILBalanceOf_Call struct {
	*mock.Call
}

// IFILBalanceOf is a helper method to define mock.On call
//   - ctx context.Context
//   - hodler common.Address
func (_e *FEVMQueries_Expecter) IFILBalanceOf(ctx interface{}, hodler interface{}) *FEVMQueries_IFILBalanceOf_Call {
	return &FEVMQueries_IFILBalanceOf_Call{Call: _e.mock.On("IFILBalanceOf", ctx, hodler)}
}

func (_c *FEVMQueries_IFILBalanceOf_Call) Run(run func(ctx context.Context, hodler common.Address)) *FEVMQueries_IFILBalanceOf_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Address))
	})
	return _c
}

func (_c *FEVMQueries_IFILBalanceOf_Call) Return(_a0 *big.Float, _a1 error) *FEVMQueries_IFILBalanceOf_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_IFILBalanceOf_Call) RunAndReturn(run func(context.Context, common.Address) (*big.Float, error)) *FEVMQueries_IFILBalanceOf_Call {
	_c.Call.Return(run)
	return _c
}

// IFILBurner provides a mock function with given fields: ctx
func (_m *FEVMQueries) IFILBurner(ctx context.Context) (common.Address, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for IFILBurner")
	}

	var r0 common.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (common.Address, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) common.Address); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_IFILBurner_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IFILBurner'
type FEVMQueries_IFILBurner_Call struct {
	*mock.Call
}

// IFILBurner is a helper method to define mock.On call
//   - ctx context.Context
func (_e *FEVMQueries_Expecter) IFILBurner(ctx interface{}) *FEVMQueries_IFILBurner_Call {
	return &FEVMQueries_IFILBurner_Call{Call: _e.mock.On("IFILBurner", ctx)}
}

func (_c *FEVMQueries_IFILBurner_Call) Run(run func(ctx context.Context)) *FEVMQueries_IFILBurner_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FEVMQueries_IFILBurner_Call) Return(_a0 common.Address, _a1 error) *FEVMQueries_IFILBurner_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_IFILBurner_Call) RunAndReturn(run func(context.Context) (common.Address, error)) *FEVMQueries_IFILBurner_Call {
	_c.Call.Return(run)
	return _c
}

// IFILMinter provides a mock function with given fields: ctx
func (_m *FEVMQueries) IFILMinter(ctx context.Context) (common.Address, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for IFILMinter")
	}

	var r0 common.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (common.Address, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) common.Address); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_IFILMinter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IFILMinter'
type FEVMQueries_IFILMinter_Call struct {
	*mock.Call
}

// IFILMinter is a helper method to define mock.On call
//   - ctx context.Context
func (_e *FEVMQueries_Expecter) IFILMinter(ctx interface{}) *FEVMQueries_IFILMinter_Call {
	return &FEVMQueries_IFILMinter_Call{Call: _e.mock.On("IFILMinter", ctx)}
}

func (_c *FEVMQueries_IFILMinter_Call) Run(run func(ctx context.Context)) *FEVMQueries_IFILMinter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FEVMQueries_IFILMinter_Call) Return(_a0 common.Address, _a1 error) *FEVMQueries_IFILMinter_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_IFILMinter_Call) RunAndReturn(run func(context.Context) (common.Address, error)) *FEVMQueries_IFILMinter_Call {
	_c.Call.Return(run)
	return _c
}

// IFILPrice provides a mock function with given fields: ctx, blockNumber
func (_m *FEVMQueries) IFILPrice(ctx context.Context, blockNumber *big.Int) (*big.Int, error) {
	ret := _m.Called(ctx, blockNumber)

	if len(ret) == 0 {
		panic("no return value specified for IFILPrice")
	}

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *big.Int) (*big.Int, error)); ok {
		return rf(ctx, blockNumber)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *big.Int) *big.Int); ok {
		r0 = rf(ctx, blockNumber)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *big.Int) error); ok {
		r1 = rf(ctx, blockNumber)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_IFILPrice_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IFILPrice'
type FEVMQueries_IFILPrice_Call struct {
	*mock.Call
}

// IFILPrice is a helper method to define mock.On call
//   - ctx context.Context
//   - blockNumber *big.Int
func (_e *FEVMQueries_Expecter) IFILPrice(ctx interface{}, blockNumber interface{}) *FEVMQueries_IFILPrice_Call {
	return &FEVMQueries_IFILPrice_Call{Call: _e.mock.On("IFILPrice", ctx, blockNumber)}
}

func (_c *FEVMQueries_IFILPrice_Call) Run(run func(ctx context.Context, blockNumber *big.Int)) *FEVMQueries_IFILPrice_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*big.Int))
	})
	return _c
}

func (_c *FEVMQueries_IFILPrice_Call) Return(_a0 *big.Int, _a1 error) *FEVMQueries_IFILPrice_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_IFILPrice_Call) RunAndReturn(run func(context.Context, *big.Int) (*big.Int, error)) *FEVMQueries_IFILPrice_Call {
	_c.Call.Return(run)
	return _c
}

// IFILSupply provides a mock function with given fields: ctx, blockNumber
func (_m *FEVMQueries) IFILSupply(ctx context.Context, blockNumber *big.Int) (*big.Int, error) {
	ret := _m.Called(ctx, blockNumber)

	if len(ret) == 0 {
		panic("no return value specified for IFILSupply")
	}

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *big.Int) (*big.Int, error)); ok {
		return rf(ctx, blockNumber)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *big.Int) *big.Int); ok {
		r0 = rf(ctx, blockNumber)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *big.Int) error); ok {
		r1 = rf(ctx, blockNumber)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_IFILSupply_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IFILSupply'
type FEVMQueries_IFILSupply_Call struct {
	*mock.Call
}

// IFILSupply is a helper method to define mock.On call
//   - ctx context.Context
//   - blockNumber *big.Int
func (_e *FEVMQueries_Expecter) IFILSupply(ctx interface{}, blockNumber interface{}) *FEVMQueries_IFILSupply_Call {
	return &FEVMQueries_IFILSupply_Call{Call: _e.mock.On("IFILSupply", ctx, blockNumber)}
}

func (_c *FEVMQueries_IFILSupply_Call) Run(run func(ctx context.Context, blockNumber *big.Int)) *FEVMQueries_IFILSupply_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*big.Int))
	})
	return _c
}

func (_c *FEVMQueries_IFILSupply_Call) Return(_a0 *big.Int, _a1 error) *FEVMQueries_IFILSupply_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_IFILSupply_Call) RunAndReturn(run func(context.Context, *big.Int) (*big.Int, error)) *FEVMQueries_IFILSupply_Call {
	_c.Call.Return(run)
	return _c
}

// InfPoolAgentMaxBorrow provides a mock function with given fields: ctx, agentAddr, agentData
func (_m *FEVMQueries) InfPoolAgentMaxBorrow(ctx context.Context, agentAddr common.Address, agentData *vc.AgentData) (*big.Int, error) {
	ret := _m.Called(ctx, agentAddr, agentData)

	if len(ret) == 0 {
		panic("no return value specified for InfPoolAgentMaxBorrow")
	}

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Address, *vc.AgentData) (*big.Int, error)); ok {
		return rf(ctx, agentAddr, agentData)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Address, *vc.AgentData) *big.Int); ok {
		r0 = rf(ctx, agentAddr, agentData)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Address, *vc.AgentData) error); ok {
		r1 = rf(ctx, agentAddr, agentData)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_InfPoolAgentMaxBorrow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InfPoolAgentMaxBorrow'
type FEVMQueries_InfPoolAgentMaxBorrow_Call struct {
	*mock.Call
}

// InfPoolAgentMaxBorrow is a helper method to define mock.On call
//   - ctx context.Context
//   - agentAddr common.Address
//   - agentData *vc.AgentData
func (_e *FEVMQueries_Expecter) InfPoolAgentMaxBorrow(ctx interface{}, agentAddr interface{}, agentData interface{}) *FEVMQueries_InfPoolAgentMaxBorrow_Call {
	return &FEVMQueries_InfPoolAgentMaxBorrow_Call{Call: _e.mock.On("InfPoolAgentMaxBorrow", ctx, agentAddr, agentData)}
}

func (_c *FEVMQueries_InfPoolAgentMaxBorrow_Call) Run(run func(ctx context.Context, agentAddr common.Address, agentData *vc.AgentData)) *FEVMQueries_InfPoolAgentMaxBorrow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Address), args[2].(*vc.AgentData))
	})
	return _c
}

func (_c *FEVMQueries_InfPoolAgentMaxBorrow_Call) Return(_a0 *big.Int, _a1 error) *FEVMQueries_InfPoolAgentMaxBorrow_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_InfPoolAgentMaxBorrow_Call) RunAndReturn(run func(context.Context, common.Address, *vc.AgentData) (*big.Int, error)) *FEVMQueries_InfPoolAgentMaxBorrow_Call {
	_c.Call.Return(run)
	return _c
}

// InfPoolApy provides a mock function with given fields: ctx, blockNumber
func (_m *FEVMQueries) InfPoolApy(ctx context.Context, blockNumber *big.Int) (*big.Int, error) {
	ret := _m.Called(ctx, blockNumber)

	if len(ret) == 0 {
		panic("no return value specified for InfPoolApy")
	}

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *big.Int) (*big.Int, error)); ok {
		return rf(ctx, blockNumber)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *big.Int) *big.Int); ok {
		r0 = rf(ctx, blockNumber)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *big.Int) error); ok {
		r1 = rf(ctx, blockNumber)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_InfPoolApy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InfPoolApy'
type FEVMQueries_InfPoolApy_Call struct {
	*mock.Call
}

// InfPoolApy is a helper method to define mock.On call
//   - ctx context.Context
//   - blockNumber *big.Int
func (_e *FEVMQueries_Expecter) InfPoolApy(ctx interface{}, blockNumber interface{}) *FEVMQueries_InfPoolApy_Call {
	return &FEVMQueries_InfPoolApy_Call{Call: _e.mock.On("InfPoolApy", ctx, blockNumber)}
}

func (_c *FEVMQueries_InfPoolApy_Call) Run(run func(ctx context.Context, blockNumber *big.Int)) *FEVMQueries_InfPoolApy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*big.Int))
	})
	return _c
}

func (_c *FEVMQueries_InfPoolApy_Call) Return(_a0 *big.Int, _a1 error) *FEVMQueries_InfPoolApy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_InfPoolApy_Call) RunAndReturn(run func(context.Context, *big.Int) (*big.Int, error)) *FEVMQueries_InfPoolApy_Call {
	_c.Call.Return(run)
	return _c
}

// InfPoolBorrowableLiquidity provides a mock function with given fields: ctx, blockNumber
func (_m *FEVMQueries) InfPoolBorrowableLiquidity(ctx context.Context, blockNumber *big.Int) (*big.Float, error) {
	ret := _m.Called(ctx, blockNumber)

	if len(ret) == 0 {
		panic("no return value specified for InfPoolBorrowableLiquidity")
	}

	var r0 *big.Float
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *big.Int) (*big.Float, error)); ok {
		return rf(ctx, blockNumber)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *big.Int) *big.Float); ok {
		r0 = rf(ctx, blockNumber)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Float)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *big.Int) error); ok {
		r1 = rf(ctx, blockNumber)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_InfPoolBorrowableLiquidity_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InfPoolBorrowableLiquidity'
type FEVMQueries_InfPoolBorrowableLiquidity_Call struct {
	*mock.Call
}

// InfPoolBorrowableLiquidity is a helper method to define mock.On call
//   - ctx context.Context
//   - blockNumber *big.Int
func (_e *FEVMQueries_Expecter) InfPoolBorrowableLiquidity(ctx interface{}, blockNumber interface{}) *FEVMQueries_InfPoolBorrowableLiquidity_Call {
	return &FEVMQueries_InfPoolBorrowableLiquidity_Call{Call: _e.mock.On("InfPoolBorrowableLiquidity", ctx, blockNumber)}
}

func (_c *FEVMQueries_InfPoolBorrowableLiquidity_Call) Run(run func(ctx context.Context, blockNumber *big.Int)) *FEVMQueries_InfPoolBorrowableLiquidity_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*big.Int))
	})
	return _c
}

func (_c *FEVMQueries_InfPoolBorrowableLiquidity_Call) Return(_a0 *big.Float, _a1 error) *FEVMQueries_InfPoolBorrowableLiquidity_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_InfPoolBorrowableLiquidity_Call) RunAndReturn(run func(context.Context, *big.Int) (*big.Float, error)) *FEVMQueries_InfPoolBorrowableLiquidity_Call {
	_c.Call.Return(run)
	return _c
}

// InfPoolExitReserve provides a mock function with given fields: ctx, blockNumber
func (_m *FEVMQueries) InfPoolExitReserve(ctx context.Context, blockNumber *big.Int) (*big.Int, *big.Int, error) {
	ret := _m.Called(ctx, blockNumber)

	if len(ret) == 0 {
		panic("no return value specified for InfPoolExitReserve")
	}

	var r0 *big.Int
	var r1 *big.Int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, *big.Int) (*big.Int, *big.Int, error)); ok {
		return rf(ctx, blockNumber)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *big.Int) *big.Int); ok {
		r0 = rf(ctx, blockNumber)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *big.Int) *big.Int); ok {
		r1 = rf(ctx, blockNumber)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*big.Int)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, *big.Int) error); ok {
		r2 = rf(ctx, blockNumber)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// FEVMQueries_InfPoolExitReserve_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InfPoolExitReserve'
type FEVMQueries_InfPoolExitReserve_Call struct {
	*mock.Call
}

// InfPoolExitReserve is a helper method to define mock.On call
//   - ctx context.Context
//   - blockNumber *big.Int
func (_e *FEVMQueries_Expecter) InfPoolExitReserve(ctx interface{}, blockNumber interface{}) *FEVMQueries_InfPoolExitReserve_Call {
	return &FEVMQueries_InfPoolExitReserve_Call{Call: _e.mock.On("InfPoolExitReserve", ctx, blockNumber)}
}

func (_c *FEVMQueries_InfPoolExitReserve_Call) Run(run func(ctx context.Context, blockNumber *big.Int)) *FEVMQueries_InfPoolExitReserve_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*big.Int))
	})
	return _c
}

func (_c *FEVMQueries_InfPoolExitReserve_Call) Return(_a0 *big.Int, _a1 *big.Int, _a2 error) *FEVMQueries_InfPoolExitReserve_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *FEVMQueries_InfPoolExitReserve_Call) RunAndReturn(run func(context.Context, *big.Int) (*big.Int, *big.Int, error)) *FEVMQueries_InfPoolExitReserve_Call {
	_c.Call.Return(run)
	return _c
}

// InfPoolFeesAccrued provides a mock function with given fields: ctx, blockNumber
func (_m *FEVMQueries) InfPoolFeesAccrued(ctx context.Context, blockNumber *big.Int) (*big.Int, error) {
	ret := _m.Called(ctx, blockNumber)

	if len(ret) == 0 {
		panic("no return value specified for InfPoolFeesAccrued")
	}

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *big.Int) (*big.Int, error)); ok {
		return rf(ctx, blockNumber)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *big.Int) *big.Int); ok {
		r0 = rf(ctx, blockNumber)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *big.Int) error); ok {
		r1 = rf(ctx, blockNumber)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_InfPoolFeesAccrued_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InfPoolFeesAccrued'
type FEVMQueries_InfPoolFeesAccrued_Call struct {
	*mock.Call
}

// InfPoolFeesAccrued is a helper method to define mock.On call
//   - ctx context.Context
//   - blockNumber *big.Int
func (_e *FEVMQueries_Expecter) InfPoolFeesAccrued(ctx interface{}, blockNumber interface{}) *FEVMQueries_InfPoolFeesAccrued_Call {
	return &FEVMQueries_InfPoolFeesAccrued_Call{Call: _e.mock.On("InfPoolFeesAccrued", ctx, blockNumber)}
}

func (_c *FEVMQueries_InfPoolFeesAccrued_Call) Run(run func(ctx context.Context, blockNumber *big.Int)) *FEVMQueries_InfPoolFeesAccrued_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*big.Int))
	})
	return _c
}

func (_c *FEVMQueries_InfPoolFeesAccrued_Call) Return(_a0 *big.Int, _a1 error) *FEVMQueries_InfPoolFeesAccrued_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_InfPoolFeesAccrued_Call) RunAndReturn(run func(context.Context, *big.Int) (*big.Int, error)) *FEVMQueries_InfPoolFeesAccrued_Call {
	_c.Call.Return(run)
	return _c
}

// InfPoolGetAccount provides a mock function with given fields: ctx, agentAddr, blockNumber
func (_m *FEVMQueries) InfPoolGetAccount(ctx context.Context, agentAddr common.Address, blockNumber *big.Int) (abigen.Account, error) {
	ret := _m.Called(ctx, agentAddr, blockNumber)

	if len(ret) == 0 {
		panic("no return value specified for InfPoolGetAccount")
	}

	var r0 abigen.Account
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Address, *big.Int) (abigen.Account, error)); ok {
		return rf(ctx, agentAddr, blockNumber)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Address, *big.Int) abigen.Account); ok {
		r0 = rf(ctx, agentAddr, blockNumber)
	} else {
		r0 = ret.Get(0).(abigen.Account)
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Address, *big.Int) error); ok {
		r1 = rf(ctx, agentAddr, blockNumber)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_InfPoolGetAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InfPoolGetAccount'
type FEVMQueries_InfPoolGetAccount_Call struct {
	*mock.Call
}

// InfPoolGetAccount is a helper method to define mock.On call
//   - ctx context.Context
//   - agentAddr common.Address
//   - blockNumber *big.Int
func (_e *FEVMQueries_Expecter) InfPoolGetAccount(ctx interface{}, agentAddr interface{}, blockNumber interface{}) *FEVMQueries_InfPoolGetAccount_Call {
	return &FEVMQueries_InfPoolGetAccount_Call{Call: _e.mock.On("InfPoolGetAccount", ctx, agentAddr, blockNumber)}
}

func (_c *FEVMQueries_InfPoolGetAccount_Call) Run(run func(ctx context.Context, agentAddr common.Address, blockNumber *big.Int)) *FEVMQueries_InfPoolGetAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Address), args[2].(*big.Int))
	})
	return _c
}

func (_c *FEVMQueries_InfPoolGetAccount_Call) Return(_a0 abigen.Account, _a1 error) *FEVMQueries_InfPoolGetAccount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_InfPoolGetAccount_Call) RunAndReturn(run func(context.Context, common.Address, *big.Int) (abigen.Account, error)) *FEVMQueries_InfPoolGetAccount_Call {
	_c.Call.Return(run)
	return _c
}

// InfPoolGetAgentLvl provides a mock function with given fields: ctx, agentID
func (_m *FEVMQueries) InfPoolGetAgentLvl(ctx context.Context, agentID *big.Int) (*big.Int, float64, error) {
	ret := _m.Called(ctx, agentID)

	if len(ret) == 0 {
		panic("no return value specified for InfPoolGetAgentLvl")
	}

	var r0 *big.Int
	var r1 float64
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, *big.Int) (*big.Int, float64, error)); ok {
		return rf(ctx, agentID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *big.Int) *big.Int); ok {
		r0 = rf(ctx, agentID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *big.Int) float64); ok {
		r1 = rf(ctx, agentID)
	} else {
		r1 = ret.Get(1).(float64)
	}

	if rf, ok := ret.Get(2).(func(context.Context, *big.Int) error); ok {
		r2 = rf(ctx, agentID)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// FEVMQueries_InfPoolGetAgentLvl_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InfPoolGetAgentLvl'
type FEVMQueries_InfPoolGetAgentLvl_Call struct {
	*mock.Call
}

// InfPoolGetAgentLvl is a helper method to define mock.On call
//   - ctx context.Context
//   - agentID *big.Int
func (_e *FEVMQueries_Expecter) InfPoolGetAgentLvl(ctx interface{}, agentID interface{}) *FEVMQueries_InfPoolGetAgentLvl_Call {
	return &FEVMQueries_InfPoolGetAgentLvl_Call{Call: _e.mock.On("InfPoolGetAgentLvl", ctx, agentID)}
}

func (_c *FEVMQueries_InfPoolGetAgentLvl_Call) Run(run func(ctx context.Context, agentID *big.Int)) *FEVMQueries_InfPoolGetAgentLvl_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*big.Int))
	})
	return _c
}

func (_c *FEVMQueries_InfPoolGetAgentLvl_Call) Return(_a0 *big.Int, _a1 float64, _a2 error) *FEVMQueries_InfPoolGetAgentLvl_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *FEVMQueries_InfPoolGetAgentLvl_Call) RunAndReturn(run func(context.Context, *big.Int) (*big.Int, float64, error)) *FEVMQueries_InfPoolGetAgentLvl_Call {
	_c.Call.Return(run)
	return _c
}

// InfPoolGetRate provides a mock function with given fields: ctx
func (_m *FEVMQueries) InfPoolGetRate(ctx context.Context) (*big.Int, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for InfPoolGetRate")
	}

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*big.Int, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *big.Int); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_InfPoolGetRate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InfPoolGetRate'
type FEVMQueries_InfPoolGetRate_Call struct {
	*mock.Call
}

// InfPoolGetRate is a helper method to define mock.On call
//   - ctx context.Context
func (_e *FEVMQueries_Expecter) InfPoolGetRate(ctx interface{}) *FEVMQueries_InfPoolGetRate_Call {
	return &FEVMQueries_InfPoolGetRate_Call{Call: _e.mock.On("InfPoolGetRate", ctx)}
}

func (_c *FEVMQueries_InfPoolGetRate_Call) Run(run func(ctx context.Context)) *FEVMQueries_InfPoolGetRate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FEVMQueries_InfPoolGetRate_Call) Return(_a0 *big.Int, _a1 error) *FEVMQueries_InfPoolGetRate_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_InfPoolGetRate_Call) RunAndReturn(run func(context.Context) (*big.Int, error)) *FEVMQueries_InfPoolGetRate_Call {
	_c.Call.Return(run)
	return _c
}

// InfPoolTotalAssets provides a mock function with given fields: ctx, blockNumber
func (_m *FEVMQueries) InfPoolTotalAssets(ctx context.Context, blockNumber *big.Int) (*big.Float, error) {
	ret := _m.Called(ctx, blockNumber)

	if len(ret) == 0 {
		panic("no return value specified for InfPoolTotalAssets")
	}

	var r0 *big.Float
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *big.Int) (*big.Float, error)); ok {
		return rf(ctx, blockNumber)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *big.Int) *big.Float); ok {
		r0 = rf(ctx, blockNumber)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Float)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *big.Int) error); ok {
		r1 = rf(ctx, blockNumber)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_InfPoolTotalAssets_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InfPoolTotalAssets'
type FEVMQueries_InfPoolTotalAssets_Call struct {
	*mock.Call
}

// InfPoolTotalAssets is a helper method to define mock.On call
//   - ctx context.Context
//   - blockNumber *big.Int
func (_e *FEVMQueries_Expecter) InfPoolTotalAssets(ctx interface{}, blockNumber interface{}) *FEVMQueries_InfPoolTotalAssets_Call {
	return &FEVMQueries_InfPoolTotalAssets_Call{Call: _e.mock.On("InfPoolTotalAssets", ctx, blockNumber)}
}

func (_c *FEVMQueries_InfPoolTotalAssets_Call) Run(run func(ctx context.Context, blockNumber *big.Int)) *FEVMQueries_InfPoolTotalAssets_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*big.Int))
	})
	return _c
}

func (_c *FEVMQueries_InfPoolTotalAssets_Call) Return(_a0 *big.Float, _a1 error) *FEVMQueries_InfPoolTotalAssets_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_InfPoolTotalAssets_Call) RunAndReturn(run func(context.Context, *big.Int) (*big.Float, error)) *FEVMQueries_InfPoolTotalAssets_Call {
	_c.Call.Return(run)
	return _c
}

// InfPoolTotalBorrowed provides a mock function with given fields: ctx, blockNumber
func (_m *FEVMQueries) InfPoolTotalBorrowed(ctx context.Context, blockNumber *big.Int) (*big.Float, error) {
	ret := _m.Called(ctx, blockNumber)

	if len(ret) == 0 {
		panic("no return value specified for InfPoolTotalBorrowed")
	}

	var r0 *big.Float
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *big.Int) (*big.Float, error)); ok {
		return rf(ctx, blockNumber)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *big.Int) *big.Float); ok {
		r0 = rf(ctx, blockNumber)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Float)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *big.Int) error); ok {
		r1 = rf(ctx, blockNumber)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_InfPoolTotalBorrowed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InfPoolTotalBorrowed'
type FEVMQueries_InfPoolTotalBorrowed_Call struct {
	*mock.Call
}

// InfPoolTotalBorrowed is a helper method to define mock.On call
//   - ctx context.Context
//   - blockNumber *big.Int
func (_e *FEVMQueries_Expecter) InfPoolTotalBorrowed(ctx interface{}, blockNumber interface{}) *FEVMQueries_InfPoolTotalBorrowed_Call {
	return &FEVMQueries_InfPoolTotalBorrowed_Call{Call: _e.mock.On("InfPoolTotalBorrowed", ctx, blockNumber)}
}

func (_c *FEVMQueries_InfPoolTotalBorrowed_Call) Run(run func(ctx context.Context, blockNumber *big.Int)) *FEVMQueries_InfPoolTotalBorrowed_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*big.Int))
	})
	return _c
}

func (_c *FEVMQueries_InfPoolTotalBorrowed_Call) Return(_a0 *big.Float, _a1 error) *FEVMQueries_InfPoolTotalBorrowed_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_InfPoolTotalBorrowed_Call) RunAndReturn(run func(context.Context, *big.Int) (*big.Float, error)) *FEVMQueries_InfPoolTotalBorrowed_Call {
	_c.Call.Return(run)
	return _c
}

// InfinityPool provides a mock function with no fields
func (_m *FEVMQueries) InfinityPool() common.Address {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for InfinityPool")
	}

	var r0 common.Address
	if rf, ok := ret.Get(0).(func() common.Address); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	return r0
}

// FEVMQueries_InfinityPool_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InfinityPool'
type FEVMQueries_InfinityPool_Call struct {
	*mock.Call
}

// InfinityPool is a helper method to define mock.On call
func (_e *FEVMQueries_Expecter) InfinityPool() *FEVMQueries_InfinityPool_Call {
	return &FEVMQueries_InfinityPool_Call{Call: _e.mock.On("InfinityPool")}
}

func (_c *FEVMQueries_InfinityPool_Call) Run(run func()) *FEVMQueries_InfinityPool_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *FEVMQueries_InfinityPool_Call) Return(_a0 common.Address) *FEVMQueries_InfinityPool_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *FEVMQueries_InfinityPool_Call) RunAndReturn(run func() common.Address) *FEVMQueries_InfinityPool_Call {
	_c.Call.Return(run)
	return _c
}

// MinerRegistry provides a mock function with no fields
func (_m *FEVMQueries) MinerRegistry() common.Address {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for MinerRegistry")
	}

	var r0 common.Address
	if rf, ok := ret.Get(0).(func() common.Address); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	return r0
}

// FEVMQueries_MinerRegistry_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MinerRegistry'
type FEVMQueries_MinerRegistry_Call struct {
	*mock.Call
}

// MinerRegistry is a helper method to define mock.On call
func (_e *FEVMQueries_Expecter) MinerRegistry() *FEVMQueries_MinerRegistry_Call {
	return &FEVMQueries_MinerRegistry_Call{Call: _e.mock.On("MinerRegistry")}
}

func (_c *FEVMQueries_MinerRegistry_Call) Run(run func()) *FEVMQueries_MinerRegistry_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *FEVMQueries_MinerRegistry_Call) Return(_a0 common.Address) *FEVMQueries_MinerRegistry_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *FEVMQueries_MinerRegistry_Call) RunAndReturn(run func() common.Address) *FEVMQueries_MinerRegistry_Call {
	_c.Call.Return(run)
	return _c
}

// MinerRegistryAgentMinersCount provides a mock function with given fields: ctx, agentID, blockNumber
func (_m *FEVMQueries) MinerRegistryAgentMinersCount(ctx context.Context, agentID *big.Int, blockNumber *big.Int) (*big.Int, error) {
	ret := _m.Called(ctx, agentID, blockNumber)

	if len(ret) == 0 {
		panic("no return value specified for MinerRegistryAgentMinersCount")
	}

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *big.Int, *big.Int) (*big.Int, error)); ok {
		return rf(ctx, agentID, blockNumber)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *big.Int, *big.Int) *big.Int); ok {
		r0 = rf(ctx, agentID, blockNumber)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *big.Int, *big.Int) error); ok {
		r1 = rf(ctx, agentID, blockNumber)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_MinerRegistryAgentMinersCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MinerRegistryAgentMinersCount'
type FEVMQueries_MinerRegistryAgentMinersCount_Call struct {
	*mock.Call
}

// MinerRegistryAgentMinersCount is a helper method to define mock.On call
//   - ctx context.Context
//   - agentID *big.Int
//   - blockNumber *big.Int
func (_e *FEVMQueries_Expecter) MinerRegistryAgentMinersCount(ctx interface{}, agentID interface{}, blockNumber interface{}) *FEVMQueries_MinerRegistryAgentMinersCount_Call {
	return &FEVMQueries_MinerRegistryAgentMinersCount_Call{Call: _e.mock.On("MinerRegistryAgentMinersCount", ctx, agentID, blockNumber)}
}

func (_c *FEVMQueries_MinerRegistryAgentMinersCount_Call) Run(run func(ctx context.Context, agentID *big.Int, blockNumber *big.Int)) *FEVMQueries_MinerRegistryAgentMinersCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*big.Int), args[2].(*big.Int))
	})
	return _c
}

func (_c *FEVMQueries_MinerRegistryAgentMinersCount_Call) Return(_a0 *big.Int, _a1 error) *FEVMQueries_MinerRegistryAgentMinersCount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_MinerRegistryAgentMinersCount_Call) RunAndReturn(run func(context.Context, *big.Int, *big.Int) (*big.Int, error)) *FEVMQueries_MinerRegistryAgentMinersCount_Call {
	_c.Call.Return(run)
	return _c
}

// MinerRegistryAgentMinersList provides a mock function with given fields: ctx, agentID, blockNumber
func (_m *FEVMQueries) MinerRegistryAgentMinersList(ctx context.Context, agentID *big.Int, blockNumber *big.Int) ([]address.Address, error) {
	ret := _m.Called(ctx, agentID, blockNumber)

	if len(ret) == 0 {
		panic("no return value specified for MinerRegistryAgentMinersList")
	}

	var r0 []address.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *big.Int, *big.Int) ([]address.Address, error)); ok {
		return rf(ctx, agentID, blockNumber)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *big.Int, *big.Int) []address.Address); ok {
		r0 = rf(ctx, agentID, blockNumber)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]address.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *big.Int, *big.Int) error); ok {
		r1 = rf(ctx, agentID, blockNumber)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_MinerRegistryAgentMinersList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MinerRegistryAgentMinersList'
type FEVMQueries_MinerRegistryAgentMinersList_Call struct {
	*mock.Call
}

// MinerRegistryAgentMinersList is a helper method to define mock.On call
//   - ctx context.Context
//   - agentID *big.Int
//   - blockNumber *big.Int
func (_e *FEVMQueries_Expecter) MinerRegistryAgentMinersList(ctx interface{}, agentID interface{}, blockNumber interface{}) *FEVMQueries_MinerRegistryAgentMinersList_Call {
	return &FEVMQueries_MinerRegistryAgentMinersList_Call{Call: _e.mock.On("MinerRegistryAgentMinersList", ctx, agentID, blockNumber)}
}

func (_c *FEVMQueries_MinerRegistryAgentMinersList_Call) Run(run func(ctx context.Context, agentID *big.Int, blockNumber *big.Int)) *FEVMQueries_MinerRegistryAgentMinersList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*big.Int), args[2].(*big.Int))
	})
	return _c
}

func (_c *FEVMQueries_MinerRegistryAgentMinersList_Call) Return(_a0 []address.Address, _a1 error) *FEVMQueries_MinerRegistryAgentMinersList_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_MinerRegistryAgentMinersList_Call) RunAndReturn(run func(context.Context, *big.Int, *big.Int) ([]address.Address, error)) *FEVMQueries_MinerRegistryAgentMinersList_Call {
	_c.Call.Return(run)
	return _c
}

// Plus provides a mock function with no fields
func (_m *FEVMQueries) Plus() common.Address {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Plus")
	}

	var r0 common.Address
	if rf, ok := ret.Get(0).(func() common.Address); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	return r0
}

// FEVMQueries_Plus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Plus'
type FEVMQueries_Plus_Call struct {
	*mock.Call
}

// Plus is a helper method to define mock.On call
func (_e *FEVMQueries_Expecter) Plus() *FEVMQueries_Plus_Call {
	return &FEVMQueries_Plus_Call{Call: _e.mock.On("Plus")}
}

func (_c *FEVMQueries_Plus_Call) Run(run func()) *FEVMQueries_Plus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *FEVMQueries_Plus_Call) Return(_a0 common.Address) *FEVMQueries_Plus_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *FEVMQueries_Plus_Call) RunAndReturn(run func() common.Address) *FEVMQueries_Plus_Call {
	_c.Call.Return(run)
	return _c
}

// PlusInfo provides a mock function with given fields: ctx, tokenID, blockNumber
func (_m *FEVMQueries) PlusInfo(ctx context.Context, tokenID *big.Int, blockNumber *big.Int) (*types.PlusInfo, error) {
	ret := _m.Called(ctx, tokenID, blockNumber)

	if len(ret) == 0 {
		panic("no return value specified for PlusInfo")
	}

	var r0 *types.PlusInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *big.Int, *big.Int) (*types.PlusInfo, error)); ok {
		return rf(ctx, tokenID, blockNumber)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *big.Int, *big.Int) *types.PlusInfo); ok {
		r0 = rf(ctx, tokenID, blockNumber)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.PlusInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *big.Int, *big.Int) error); ok {
		r1 = rf(ctx, tokenID, blockNumber)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_PlusInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PlusInfo'
type FEVMQueries_PlusInfo_Call struct {
	*mock.Call
}

// PlusInfo is a helper method to define mock.On call
//   - ctx context.Context
//   - tokenID *big.Int
//   - blockNumber *big.Int
func (_e *FEVMQueries_Expecter) PlusInfo(ctx interface{}, tokenID interface{}, blockNumber interface{}) *FEVMQueries_PlusInfo_Call {
	return &FEVMQueries_PlusInfo_Call{Call: _e.mock.On("PlusInfo", ctx, tokenID, blockNumber)}
}

func (_c *FEVMQueries_PlusInfo_Call) Run(run func(ctx context.Context, tokenID *big.Int, blockNumber *big.Int)) *FEVMQueries_PlusInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*big.Int), args[2].(*big.Int))
	})
	return _c
}

func (_c *FEVMQueries_PlusInfo_Call) Return(_a0 *types.PlusInfo, _a1 error) *FEVMQueries_PlusInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_PlusInfo_Call) RunAndReturn(run func(context.Context, *big.Int, *big.Int) (*types.PlusInfo, error)) *FEVMQueries_PlusInfo_Call {
	_c.Call.Return(run)
	return _c
}

// PlusTierFromAgentAddress provides a mock function with given fields: ctx, agentAddr, blockNumber
func (_m *FEVMQueries) PlusTierFromAgentAddress(ctx context.Context, agentAddr common.Address, blockNumber *big.Int) (uint8, error) {
	ret := _m.Called(ctx, agentAddr, blockNumber)

	if len(ret) == 0 {
		panic("no return value specified for PlusTierFromAgentAddress")
	}

	var r0 uint8
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Address, *big.Int) (uint8, error)); ok {
		return rf(ctx, agentAddr, blockNumber)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Address, *big.Int) uint8); ok {
		r0 = rf(ctx, agentAddr, blockNumber)
	} else {
		r0 = ret.Get(0).(uint8)
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Address, *big.Int) error); ok {
		r1 = rf(ctx, agentAddr, blockNumber)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_PlusTierFromAgentAddress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PlusTierFromAgentAddress'
type FEVMQueries_PlusTierFromAgentAddress_Call struct {
	*mock.Call
}

// PlusTierFromAgentAddress is a helper method to define mock.On call
//   - ctx context.Context
//   - agentAddr common.Address
//   - blockNumber *big.Int
func (_e *FEVMQueries_Expecter) PlusTierFromAgentAddress(ctx interface{}, agentAddr interface{}, blockNumber interface{}) *FEVMQueries_PlusTierFromAgentAddress_Call {
	return &FEVMQueries_PlusTierFromAgentAddress_Call{Call: _e.mock.On("PlusTierFromAgentAddress", ctx, agentAddr, blockNumber)}
}

func (_c *FEVMQueries_PlusTierFromAgentAddress_Call) Run(run func(ctx context.Context, agentAddr common.Address, blockNumber *big.Int)) *FEVMQueries_PlusTierFromAgentAddress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Address), args[2].(*big.Int))
	})
	return _c
}

func (_c *FEVMQueries_PlusTierFromAgentAddress_Call) Return(_a0 uint8, _a1 error) *FEVMQueries_PlusTierFromAgentAddress_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_PlusTierFromAgentAddress_Call) RunAndReturn(run func(context.Context, common.Address, *big.Int) (uint8, error)) *FEVMQueries_PlusTierFromAgentAddress_Call {
	_c.Call.Return(run)
	return _c
}

// PlusTierInfo provides a mock function with given fields: ctx, blockNumber
func (_m *FEVMQueries) PlusTierInfo(ctx context.Context, blockNumber *big.Int) ([]abigen.TierInfo, error) {
	ret := _m.Called(ctx, blockNumber)

	if len(ret) == 0 {
		panic("no return value specified for PlusTierInfo")
	}

	var r0 []abigen.TierInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *big.Int) ([]abigen.TierInfo, error)); ok {
		return rf(ctx, blockNumber)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *big.Int) []abigen.TierInfo); ok {
		r0 = rf(ctx, blockNumber)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]abigen.TierInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *big.Int) error); ok {
		r1 = rf(ctx, blockNumber)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_PlusTierInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PlusTierInfo'
type FEVMQueries_PlusTierInfo_Call struct {
	*mock.Call
}

// PlusTierInfo is a helper method to define mock.On call
//   - ctx context.Context
//   - blockNumber *big.Int
func (_e *FEVMQueries_Expecter) PlusTierInfo(ctx interface{}, blockNumber interface{}) *FEVMQueries_PlusTierInfo_Call {
	return &FEVMQueries_PlusTierInfo_Call{Call: _e.mock.On("PlusTierInfo", ctx, blockNumber)}
}

func (_c *FEVMQueries_PlusTierInfo_Call) Run(run func(ctx context.Context, blockNumber *big.Int)) *FEVMQueries_PlusTierInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*big.Int))
	})
	return _c
}

func (_c *FEVMQueries_PlusTierInfo_Call) Return(_a0 []abigen.TierInfo, _a1 error) *FEVMQueries_PlusTierInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_PlusTierInfo_Call) RunAndReturn(run func(context.Context, *big.Int) ([]abigen.TierInfo, error)) *FEVMQueries_PlusTierInfo_Call {
	_c.Call.Return(run)
	return _c
}

// PlusTokenIDFromRcpt provides a mock function with given fields: ctx, receipt
func (_m *FEVMQueries) PlusTokenIDFromRcpt(ctx context.Context, receipt *coretypes.Receipt) (*big.Int, error) {
	ret := _m.Called(ctx, receipt)

	if len(ret) == 0 {
		panic("no return value specified for PlusTokenIDFromRcpt")
	}

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *coretypes.Receipt) (*big.Int, error)); ok {
		return rf(ctx, receipt)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *coretypes.Receipt) *big.Int); ok {
		r0 = rf(ctx, receipt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *coretypes.Receipt) error); ok {
		r1 = rf(ctx, receipt)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_PlusTokenIDFromRcpt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PlusTokenIDFromRcpt'
type FEVMQueries_PlusTokenIDFromRcpt_Call struct {
	*mock.Call
}

// PlusTokenIDFromRcpt is a helper method to define mock.On call
//   - ctx context.Context
//   - receipt *coretypes.Receipt
func (_e *FEVMQueries_Expecter) PlusTokenIDFromRcpt(ctx interface{}, receipt interface{}) *FEVMQueries_PlusTokenIDFromRcpt_Call {
	return &FEVMQueries_PlusTokenIDFromRcpt_Call{Call: _e.mock.On("PlusTokenIDFromRcpt", ctx, receipt)}
}

func (_c *FEVMQueries_PlusTokenIDFromRcpt_Call) Run(run func(ctx context.Context, receipt *coretypes.Receipt)) *FEVMQueries_PlusTokenIDFromRcpt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*coretypes.Receipt))
	})
	return _c
}

func (_c *FEVMQueries_PlusTokenIDFromRcpt_Call) Return(_a0 *big.Int, _a1 error) *FEVMQueries_PlusTokenIDFromRcpt_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_PlusTokenIDFromRcpt_Call) RunAndReturn(run func(context.Context, *coretypes.Receipt) (*big.Int, error)) *FEVMQueries_PlusTokenIDFromRcpt_Call {
	_c.Call.Return(run)
	return _c
}

// Router provides a mock function with no fields
func (_m *FEVMQueries) Router() common.Address {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Router")
	}

	var r0 common.Address
	if rf, ok := ret.Get(0).(func() common.Address); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	return r0
}

// FEVMQueries_Router_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Router'
type FEVMQueries_Router_Call struct {
	*mock.Call
}

// Router is a helper method to define mock.On call
func (_e *FEVMQueries_Expecter) Router() *FEVMQueries_Router_Call {
	return &FEVMQueries_Router_Call{Call: _e.mock.On("Router")}
}

func (_c *FEVMQueries_Router_Call) Run(run func()) *FEVMQueries_Router_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *FEVMQueries_Router_Call) Return(_a0 common.Address) *FEVMQueries_Router_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *FEVMQueries_Router_Call) RunAndReturn(run func() common.Address) *FEVMQueries_Router_Call {
	_c.Call.Return(run)
	return _c
}

// RouterGetRoute provides a mock function with given fields: ctx, route
func (_m *FEVMQueries) RouterGetRoute(ctx context.Context, route constants.Route) (common.Address, error) {
	ret := _m.Called(ctx, route)

	if len(ret) == 0 {
		panic("no return value specified for RouterGetRoute")
	}

	var r0 common.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, constants.Route) (common.Address, error)); ok {
		return rf(ctx, route)
	}
	if rf, ok := ret.Get(0).(func(context.Context, constants.Route) common.Address); ok {
		r0 = rf(ctx, route)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, constants.Route) error); ok {
		r1 = rf(ctx, route)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_RouterGetRoute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RouterGetRoute'
type FEVMQueries_RouterGetRoute_Call struct {
	*mock.Call
}

// RouterGetRoute is a helper method to define mock.On call
//   - ctx context.Context
//   - route constants.Route
func (_e *FEVMQueries_Expecter) RouterGetRoute(ctx interface{}, route interface{}) *FEVMQueries_RouterGetRoute_Call {
	return &FEVMQueries_RouterGetRoute_Call{Call: _e.mock.On("RouterGetRoute", ctx, route)}
}

func (_c *FEVMQueries_RouterGetRoute_Call) Run(run func(ctx context.Context, route constants.Route)) *FEVMQueries_RouterGetRoute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(constants.Route))
	})
	return _c
}

func (_c *FEVMQueries_RouterGetRoute_Call) Return(_a0 common.Address, _a1 error) *FEVMQueries_RouterGetRoute_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_RouterGetRoute_Call) RunAndReturn(run func(context.Context, constants.Route) (common.Address, error)) *FEVMQueries_RouterGetRoute_Call {
	_c.Call.Return(run)
	return _c
}

// RouterOwner provides a mock function with given fields: ctx
func (_m *FEVMQueries) RouterOwner(ctx context.Context) (common.Address, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for RouterOwner")
	}

	var r0 common.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (common.Address, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) common.Address); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_RouterOwner_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RouterOwner'
type FEVMQueries_RouterOwner_Call struct {
	*mock.Call
}

// RouterOwner is a helper method to define mock.On call
//   - ctx context.Context
func (_e *FEVMQueries_Expecter) RouterOwner(ctx interface{}) *FEVMQueries_RouterOwner_Call {
	return &FEVMQueries_RouterOwner_Call{Call: _e.mock.On("RouterOwner", ctx)}
}

func (_c *FEVMQueries_RouterOwner_Call) Run(run func(ctx context.Context)) *FEVMQueries_RouterOwner_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FEVMQueries_RouterOwner_Call) Return(_a0 common.Address, _a1 error) *FEVMQueries_RouterOwner_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_RouterOwner_Call) RunAndReturn(run func(context.Context) (common.Address, error)) *FEVMQueries_RouterOwner_Call {
	_c.Call.Return(run)
	return _c
}

// SectorFaultyTolerance provides a mock function with given fields: ctx
func (_m *FEVMQueries) SectorFaultyTolerance(ctx context.Context) (*big.Int, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for SectorFaultyTolerance")
	}

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*big.Int, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *big.Int); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_SectorFaultyTolerance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SectorFaultyTolerance'
type FEVMQueries_SectorFaultyTolerance_Call struct {
	*mock.Call
}

// SectorFaultyTolerance is a helper method to define mock.On call
//   - ctx context.Context
func (_e *FEVMQueries_Expecter) SectorFaultyTolerance(ctx interface{}) *FEVMQueries_SectorFaultyTolerance_Call {
	return &FEVMQueries_SectorFaultyTolerance_Call{Call: _e.mock.On("SectorFaultyTolerance", ctx)}
}

func (_c *FEVMQueries_SectorFaultyTolerance_Call) Run(run func(ctx context.Context)) *FEVMQueries_SectorFaultyTolerance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *FEVMQueries_SectorFaultyTolerance_Call) Return(_a0 *big.Int, _a1 error) *FEVMQueries_SectorFaultyTolerance_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_SectorFaultyTolerance_Call) RunAndReturn(run func(context.Context) (*big.Int, error)) *FEVMQueries_SectorFaultyTolerance_Call {
	_c.Call.Return(run)
	return _c
}

// StateWaitNextTick provides a mock function with given fields: ctx, currentEpochHeight
func (_m *FEVMQueries) StateWaitNextTick(ctx context.Context, currentEpochHeight *big.Int) error {
	ret := _m.Called(ctx, currentEpochHeight)

	if len(ret) == 0 {
		panic("no return value specified for StateWaitNextTick")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *big.Int) error); ok {
		r0 = rf(ctx, currentEpochHeight)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FEVMQueries_StateWaitNextTick_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateWaitNextTick'
type FEVMQueries_StateWaitNextTick_Call struct {
	*mock.Call
}

// StateWaitNextTick is a helper method to define mock.On call
//   - ctx context.Context
//   - currentEpochHeight *big.Int
func (_e *FEVMQueries_Expecter) StateWaitNextTick(ctx interface{}, currentEpochHeight interface{}) *FEVMQueries_StateWaitNextTick_Call {
	return &FEVMQueries_StateWaitNextTick_Call{Call: _e.mock.On("StateWaitNextTick", ctx, currentEpochHeight)}
}

func (_c *FEVMQueries_StateWaitNextTick_Call) Run(run func(ctx context.Context, currentEpochHeight *big.Int)) *FEVMQueries_StateWaitNextTick_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*big.Int))
	})
	return _c
}

func (_c *FEVMQueries_StateWaitNextTick_Call) Return(_a0 error) *FEVMQueries_StateWaitNextTick_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *FEVMQueries_StateWaitNextTick_Call) RunAndReturn(run func(context.Context, *big.Int) error) *FEVMQueries_StateWaitNextTick_Call {
	_c.Call.Return(run)
	return _c
}

// StateWaitReceipt provides a mock function with given fields: ctx, txHash
func (_m *FEVMQueries) StateWaitReceipt(ctx context.Context, txHash common.Hash) (*coretypes.Receipt, error) {
	ret := _m.Called(ctx, txHash)

	if len(ret) == 0 {
		panic("no return value specified for StateWaitReceipt")
	}

	var r0 *coretypes.Receipt
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Hash) (*coretypes.Receipt, error)); ok {
		return rf(ctx, txHash)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Hash) *coretypes.Receipt); ok {
		r0 = rf(ctx, txHash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.Receipt)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Hash) error); ok {
		r1 = rf(ctx, txHash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_StateWaitReceipt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateWaitReceipt'
type FEVMQueries_StateWaitReceipt_Call struct {
	*mock.Call
}

// StateWaitReceipt is a helper method to define mock.On call
//   - ctx context.Context
//   - txHash common.Hash
func (_e *FEVMQueries_Expecter) StateWaitReceipt(ctx interface{}, txHash interface{}) *FEVMQueries_StateWaitReceipt_Call {
	return &FEVMQueries_StateWaitReceipt_Call{Call: _e.mock.On("StateWaitReceipt", ctx, txHash)}
}

func (_c *FEVMQueries_StateWaitReceipt_Call) Run(run func(ctx context.Context, txHash common.Hash)) *FEVMQueries_StateWaitReceipt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Hash))
	})
	return _c
}

func (_c *FEVMQueries_StateWaitReceipt_Call) Return(_a0 *coretypes.Receipt, _a1 error) *FEVMQueries_StateWaitReceipt_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_StateWaitReceipt_Call) RunAndReturn(run func(context.Context, common.Hash) (*coretypes.Receipt, error)) *FEVMQueries_StateWaitReceipt_Call {
	_c.Call.Return(run)
	return _c
}

// StateWaitTx provides a mock function with given fields: ctx, txHash, ch
func (_m *FEVMQueries) StateWaitTx(ctx context.Context, txHash common.Hash, ch chan *coretypes.Receipt) {
	_m.Called(ctx, txHash, ch)
}

// FEVMQueries_StateWaitTx_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateWaitTx'
type FEVMQueries_StateWaitTx_Call struct {
	*mock.Call
}

// StateWaitTx is a helper method to define mock.On call
//   - ctx context.Context
//   - txHash common.Hash
//   - ch chan *coretypes.Receipt
func (_e *FEVMQueries_Expecter) StateWaitTx(ctx interface{}, txHash interface{}, ch interface{}) *FEVMQueries_StateWaitTx_Call {
	return &FEVMQueries_StateWaitTx_Call{Call: _e.mock.On("StateWaitTx", ctx, txHash, ch)}
}

func (_c *FEVMQueries_StateWaitTx_Call) Run(run func(ctx context.Context, txHash common.Hash, ch chan *coretypes.Receipt)) *FEVMQueries_StateWaitTx_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Hash), args[2].(chan *coretypes.Receipt))
	})
	return _c
}

func (_c *FEVMQueries_StateWaitTx_Call) Return() *FEVMQueries_StateWaitTx_Call {
	_c.Call.Return()
	return _c
}

func (_c *FEVMQueries_StateWaitTx_Call) RunAndReturn(run func(context.Context, common.Hash, chan *coretypes.Receipt)) *FEVMQueries_StateWaitTx_Call {
	_c.Run(run)
	return _c
}

// TokenNFTWrapper provides a mock function with no fields
func (_m *FEVMQueries) TokenNFTWrapper() common.Address {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for TokenNFTWrapper")
	}

	var r0 common.Address
	if rf, ok := ret.Get(0).(func() common.Address); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	return r0
}

// FEVMQueries_TokenNFTWrapper_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TokenNFTWrapper'
type FEVMQueries_TokenNFTWrapper_Call struct {
	*mock.Call
}

// TokenNFTWrapper is a helper method to define mock.On call
func (_e *FEVMQueries_Expecter) TokenNFTWrapper() *FEVMQueries_TokenNFTWrapper_Call {
	return &FEVMQueries_TokenNFTWrapper_Call{Call: _e.mock.On("TokenNFTWrapper")}
}

func (_c *FEVMQueries_TokenNFTWrapper_Call) Run(run func()) *FEVMQueries_TokenNFTWrapper_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *FEVMQueries_TokenNFTWrapper_Call) Return(_a0 common.Address) *FEVMQueries_TokenNFTWrapper_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *FEVMQueries_TokenNFTWrapper_Call) RunAndReturn(run func() common.Address) *FEVMQueries_TokenNFTWrapper_Call {
	_c.Call.Return(run)
	return _c
}

// TreasuryFeeRate provides a mock function with given fields: ctx, blockNumber
func (_m *FEVMQueries) TreasuryFeeRate(ctx context.Context, blockNumber *big.Int) (*big.Int, error) {
	ret := _m.Called(ctx, blockNumber)

	if len(ret) == 0 {
		panic("no return value specified for TreasuryFeeRate")
	}

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *big.Int) (*big.Int, error)); ok {
		return rf(ctx, blockNumber)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *big.Int) *big.Int); ok {
		r0 = rf(ctx, blockNumber)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *big.Int) error); ok {
		r1 = rf(ctx, blockNumber)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_TreasuryFeeRate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TreasuryFeeRate'
type FEVMQueries_TreasuryFeeRate_Call struct {
	*mock.Call
}

// TreasuryFeeRate is a helper method to define mock.On call
//   - ctx context.Context
//   - blockNumber *big.Int
func (_e *FEVMQueries_Expecter) TreasuryFeeRate(ctx interface{}, blockNumber interface{}) *FEVMQueries_TreasuryFeeRate_Call {
	return &FEVMQueries_TreasuryFeeRate_Call{Call: _e.mock.On("TreasuryFeeRate", ctx, blockNumber)}
}

func (_c *FEVMQueries_TreasuryFeeRate_Call) Run(run func(ctx context.Context, blockNumber *big.Int)) *FEVMQueries_TreasuryFeeRate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*big.Int))
	})
	return _c
}

func (_c *FEVMQueries_TreasuryFeeRate_Call) Return(_a0 *big.Int, _a1 error) *FEVMQueries_TreasuryFeeRate_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_TreasuryFeeRate_Call) RunAndReturn(run func(context.Context, *big.Int) (*big.Int, error)) *FEVMQueries_TreasuryFeeRate_Call {
	_c.Call.Return(run)
	return _c
}

// WFIL provides a mock function with no fields
func (_m *FEVMQueries) WFIL() common.Address {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for WFIL")
	}

	var r0 common.Address
	if rf, ok := ret.Get(0).(func() common.Address); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	return r0
}

// FEVMQueries_WFIL_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WFIL'
type FEVMQueries_WFIL_Call struct {
	*mock.Call
}

// WFIL is a helper method to define mock.On call
func (_e *FEVMQueries_Expecter) WFIL() *FEVMQueries_WFIL_Call {
	return &FEVMQueries_WFIL_Call{Call: _e.mock.On("WFIL")}
}

func (_c *FEVMQueries_WFIL_Call) Run(run func()) *FEVMQueries_WFIL_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *FEVMQueries_WFIL_Call) Return(_a0 common.Address) *FEVMQueries_WFIL_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *FEVMQueries_WFIL_Call) RunAndReturn(run func() common.Address) *FEVMQueries_WFIL_Call {
	_c.Call.Return(run)
	return _c
}

// WFILAllowance provides a mock function with given fields: ctx, hodler, spender
func (_m *FEVMQueries) WFILAllowance(ctx context.Context, hodler common.Address, spender common.Address) (*big.Float, error) {
	ret := _m.Called(ctx, hodler, spender)

	if len(ret) == 0 {
		panic("no return value specified for WFILAllowance")
	}

	var r0 *big.Float
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Address, common.Address) (*big.Float, error)); ok {
		return rf(ctx, hodler, spender)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Address, common.Address) *big.Float); ok {
		r0 = rf(ctx, hodler, spender)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Float)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Address, common.Address) error); ok {
		r1 = rf(ctx, hodler, spender)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_WFILAllowance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WFILAllowance'
type FEVMQueries_WFILAllowance_Call struct {
	*mock.Call
}

// WFILAllowance is a helper method to define mock.On call
//   - ctx context.Context
//   - hodler common.Address
//   - spender common.Address
func (_e *FEVMQueries_Expecter) WFILAllowance(ctx interface{}, hodler interface{}, spender interface{}) *FEVMQueries_WFILAllowance_Call {
	return &FEVMQueries_WFILAllowance_Call{Call: _e.mock.On("WFILAllowance", ctx, hodler, spender)}
}

func (_c *FEVMQueries_WFILAllowance_Call) Run(run func(ctx context.Context, hodler common.Address, spender common.Address)) *FEVMQueries_WFILAllowance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Address), args[2].(common.Address))
	})
	return _c
}

func (_c *FEVMQueries_WFILAllowance_Call) Return(_a0 *big.Float, _a1 error) *FEVMQueries_WFILAllowance_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_WFILAllowance_Call) RunAndReturn(run func(context.Context, common.Address, common.Address) (*big.Float, error)) *FEVMQueries_WFILAllowance_Call {
	_c.Call.Return(run)
	return _c
}

// WFILBalanceOf provides a mock function with given fields: ctx, hodler
func (_m *FEVMQueries) WFILBalanceOf(ctx context.Context, hodler common.Address) (*big.Float, error) {
	ret := _m.Called(ctx, hodler)

	if len(ret) == 0 {
		panic("no return value specified for WFILBalanceOf")
	}

	var r0 *big.Float
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) (*big.Float, error)); ok {
		return rf(ctx, hodler)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) *big.Float); ok {
		r0 = rf(ctx, hodler)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Float)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Address) error); ok {
		r1 = rf(ctx, hodler)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FEVMQueries_WFILBalanceOf_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WFILBalanceOf'
type FEVMQueries_WFILBalanceOf_Call struct {
	*mock.Call
}

// WFILBalanceOf is a helper method to define mock.On call
//   - ctx context.Context
//   - hodler common.Address
func (_e *FEVMQueries_Expecter) WFILBalanceOf(ctx interface{}, hodler interface{}) *FEVMQueries_WFILBalanceOf_Call {
	return &FEVMQueries_WFILBalanceOf_Call{Call: _e.mock.On("WFILBalanceOf", ctx, hodler)}
}

func (_c *FEVMQueries_WFILBalanceOf_Call) Run(run func(ctx context.Context, hodler common.Address)) *FEVMQueries_WFILBalanceOf_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Address))
	})
	return _c
}

func (_c *FEVMQueries_WFILBalanceOf_Call) Return(_a0 *big.Float, _a1 error) *FEVMQueries_WFILBalanceOf_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *FEVMQueries_WFILBalanceOf_Call) RunAndReturn(run func(context.Context, common.Address) (*big.Float, error)) *FEVMQueries_WFILBalanceOf_Call {
	_c.Call.Return(run)
	return _c
}

// NewFEVMQueries creates a new instance of FEVMQueries. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewFEVMQueries(t interface {
	mock.TestingT
	Cleanup(func())
}) *FEVMQueries {
	mock := &FEVMQueries{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
